* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

#+begin_quote
Role models are important.

---  Officer Alex J. Murphy / RoboCop

#+end_quote

This Clojure style guide recommends best practices so that real-world
Clojure programmers can write code that can be maintained by other
real-world Clojure programmers. A style guide that reflects real-world
usage gets used, and a style guide that holds to an ideal that has been
rejected by the people it is supposed to help risks not getting used at
all --- no matter how good it is.

The guide is separated into several sections of related rules. we've
tried to add the rationale behind the rules (if it's omitted, we've
assumed that it's pretty obvious).

We didn't come up with all the rules out of nowhere; they are mostly
based on the experience of the style guide's editors, feedback and
suggestions from numerous members of the Clojure community, and various
highly regarded Clojure programming resources, such as
[[https://www.clojurebook.com/]["Clojure Programming"]] and
[[http://www.joyofclojure.com/]["The Joy of Clojure"]].

Nothing written here is set in stone. This style guide evolves over time
as additional conventions are identified and past conventions are
rendered obsolete by changes in Clojure itself.

Clojure's developers also maintain a list of
[[https://clojure.org/community/contrib_howto#_coding_guidelines][coding
guidelines for libraries]].[fn:1] They were one of the sources of
inspiration for the document, you're currently reading.

** Guiding Principles
:PROPERTIES:
:CUSTOM_ID: guiding_principles
:END:

#+begin_quote
Programs must be written for people to read, and only incidentally for
machines to execute.

---  Harold Abelson Structure and Interpretation of Computer Programs

#+end_quote

It's common knowledge that code is read much more often than it is
written. The guidelines provided here are intended to improve the
readability of code and make it consistent across the wide spectrum of
Clojure code. They are also meant to reflect real-world usage of Clojure
instead of a random ideal. When we had to choose between a very
established practice and a subjectively better alternative we've opted
to recommend the established practice.[fn:2]

There are some areas in which there is no clear consensus in the Clojure
community regarding a particular style (like semantic indentation vs
fixed indentation, semantic comments vs uniform comments, etc). In such
scenarios all popular styles are acknowledged and it's up to you to pick
one and apply it consistently.

Fortunately Clojure is a Lisp, and Lisps are fundamentally simple. Even
though this guide was created a few years after Clojure (the first
version was published in early 2013), you could see that most Clojure
code in the wild was fairly uniform. We attribute this to both the
simplicity we already mentioned and to the fact that since day 1
Clojurists adopted many of the style conventions of other established
Lisp dialects (e.g. Common Lisp and Scheme). This made the work on this
guide fairly easy and straight-forward, especially compared to the
massive exercise in frustration that was the
[[https://rubystyle.guide][Community Ruby Style Guide]].[fn:3]

Clojure is famously optimized for simplicity and clarity. We'd like to
believe that this guide is going to help you optimize for maximum
simplicity and clarity.

** A Note About Consistency
:PROPERTIES:
:CUSTOM_ID: a_note_about_consistency
:END:

#+begin_quote
A foolish consistency is the hobgoblin of little minds, adored by little
statesmen and philosophers and divines.

---  Ralph Waldo Emerson

#+end_quote

A style guide is about consistency.[fn:4] Consistency with this style
guide is important. Consistency within a project is more important.
Consistency within one class or method is the most important.

However, know when to be inconsistent --- sometimes style guide
recommendations just aren't applicable. When in doubt, use your best
judgment. Look at other examples and decide what looks best. And don't
hesitate to ask!

In particular: do not break backwards compatibility just to comply with
this guide!

Some other good reasons to ignore a particular guideline:

- When applying the guideline would make the code less readable, even
  for someone who is used to reading code that follows this style guide.

- To be consistent with surrounding code that also breaks it (maybe for
  historic reasons) --- although this is also an opportunity to clean up
  someone else's mess (in true XP style).

- Because the code in question predates the introduction of the
  guideline and there is no other reason to be modifying that code.

- When the code needs to remain compatible with older versions of
  Clojure that don't support the feature recommended by the style guide.

** Translations
:PROPERTIES:
:CUSTOM_ID: translations
:END:
Translations of the guide are available in the following languages:

- [[https://github.com/geekerzp/clojure-style-guide/blob/master/README-zhCN.md][Chinese]]

- [[https://github.com/totakke/clojure-style-guide/blob/ja/README.adoc][Japanese]]

- [[https://github.com/kwakbab/clojure-style-guide/blob/master/README-koKO.md][Korean]]

- [[https://github.com/theSkilled/clojure-style-guide/blob/pt-BR/README.md][Portuguese]]
  (Under progress)

- [[https://github.com/Nondv/clojure-style-guide/blob/master/ru/README.md][Russian]]

- [[https://github.com/jeko2000/clojure-style-guide/blob/master/README.md][Spanish]]

- [[https://github.com/LeaveNhA/clojure-style-guide/blob/master/README.adoc][Turkish]]

These translations are not maintained by our editor team, so their
quality and level of completeness may vary. The translated versions of
the guide often lag behind the upstream English version.

* Source Code Layout & Organization
:PROPERTIES:
:CUSTOM_ID: source_code_layout_amp_organization
:END:

#+begin_quote
Nearly everybody is convinced that every style but their own is ugly and
unreadable. Leave out the "but their own" and they're probably right...

---  Jerry Coffin (on indentation)

#+end_quote

Where feasible, avoid making lines longer than 80 characters.

A lot of people these days feel that a maximum line length of 80
characters is just a remnant of the past and makes little sense today.
After all - modern displays can easily fit 200+ characters on a single
line. Still, there are some important benefits to be gained from
sticking to shorter lines of code.

First, and foremost - numerous studies have shown that humans read much
faster vertically and very long lines of text impede the reading
process. As noted earlier, one of the guiding principles of this style
guide is to optimize the code we write for human consumption.

Additionally, limiting the required editor window width makes it
possible to have several files open side-by-side, and works well when
using code review tools that present the two versions in adjacent
columns.

The default wrapping in most tools disrupts the visual structure of the
code, making it more difficult to understand. The limits are chosen to
avoid wrapping in editors with the window width set to 80, even if the
tool places a marker glyph in the final column when wrapping lines. Some
web based tools may not offer dynamic line wrapping at all.

Some teams strongly prefer a longer line length. For code maintained
exclusively or primarily by a team that can reach agreement on this
issue, it is okay to increase the line length limit up to 100
characters, or all the way up to 120 characters. Please, restrain the
urge to go beyond 120 characters.

** Tabs vs Spaces <<spaces>>
:PROPERTIES:
:CUSTOM_ID: tabs_vs_spaces_anchor_id_spaces_xreflabel_spaces
:END:
Use *spaces* for indentation. No hard tabs.

** Body Indentation <<body-indentation>>
:PROPERTIES:
:CUSTOM_ID: body_indentation_anchor_id_body_indentation_xreflabel_body_indentation
:END:
Use 2 spaces to indent the bodies of forms that have body parameters.
This covers all =def= forms, special forms and macros that introduce
local bindings (e.g. =loop=, =let=, =when-let=) and many macros like
=when=, =cond=, =+as->+=, =+cond->+=, =case=, =with-*=, etc.

#+begin_src clojure
;; good
(when something
  (something-else))

(with-out-str
  (println "Hello, ")
  (println "world!"))

;; bad - four spaces
(when something
    (something-else))

;; bad - one space
(with-out-str
 (println "Hello, ")
 (println "world!"))
#+end_src

** Function Arguments Alignment <<vertically-align-fn-args>>
:PROPERTIES:
:CUSTOM_ID: function_arguments_alignment_anchor_id_vertically_align_fn_args_xreflabel_vertically_align_fn_args
:END:
Vertically align function (macro) arguments spanning multiple lines.

#+begin_src clojure
;; good
(filter even?
        (range 1 10))

;; bad - argument aligned with function name (one space indent)
(filter even?
 (range 1 10))

;; bad - two space indent
(filter even?
  (range 1 10))
#+end_src

The reasoning behind this guideline is pretty simple - the arguments are
easier to process by the human brain if they stand out and stick
together.

** Function Arguments Indentation <<one-space-indent>>
:PROPERTIES:
:CUSTOM_ID: function_arguments_indentation_anchor_id_one_space_indent_xreflabel_one_space_indent
:END:

Generally, you should stick to the formatting outlined in the previous
guideline, unless you're limited by the available horizontal space.

Use a single space indentation for function (macro) arguments when there
are no arguments on the same line as the function name.

#+begin_src clojure
;; good
(filter
 even?
 (range 1 10))

(or
 ala
 bala
 portokala)

;; bad - two-space indent
(filter
  even?
  (range 1 10))

(or
  ala
  bala
  portokala)
#+end_src

This may appear like some weird special rule to people without Lisp
background, but the reasoning behind it is quite simple. Function calls
are nothing but regular list literals and normally those are aligned in
the same way as other collection type literals when spanning multiple
lines:

#+begin_src clojure
;; list literal
(1
 2
 3)

;; vector literal
[1
 2
 3]

;; set literal
#{1
  2
  3}
#+end_src

Admittedly, list literals are not very common in Clojure, that's why
it's understandable that for many people lists are nothing but an
invocation syntax.

As a side benefit, function arguments are still aligned in this scenario
as well. They just happen to accidentally be aligned with the function
name as well.

The guidelines to indent differently macros with body forms from all
other macro and function calls are collectively known as "semantic
indentation". Simply put, this means that the code is indented
differently, so that the indentation would give the reader of the code
some hints about its meaning.

The downside of this approach is that requires Clojure code formatters
to be smarter. They either need to process =macro= arglists and rely on
the fact that people named their parameters consistently, or process
some additional indentation metadata.

Some people in the Clojure community have argued that's not worth it and
that everything should simply be indented in the same fashion. Here are
a few examples:

#+begin_src clojure
;;; Fixed Indentation
;;
;; macros
(when something
  (something-else))

(with-out-str
  (println "Hello, ")
  (println "world!"))

;; function call spanning two lines
(filter even?
  (range 1 10))

;; function call spanning three lines
(filter
  even?
  (range 1 10))
#+end_src

This suggestion has certainly gotten some ground in the community, but
it also goes against much of the Lisp tradition and one of the primary
goals of this style guide - namely to optimize code for human
consumption.

There's one exception to the fixed indentation rule - data lists (those
that are not a function invocation):

#+begin_src clojure
;;; Fixed Indentation
;;
;; list literals
;; we still do
(1
 2
 3
 4
 5
 6)

;; and
(1 2 3
 4 5 6)

;; instead of
(1 2 3
  4 5 6)

;; or
(1
  2
  3
  4
  5
  6)
#+end_src

This makes sure that lists are consistent with how other collection
types are normally indented.

** Bindings Alignment <<bindings-alignment>>
:PROPERTIES:
:CUSTOM_ID: bindings_alignment_anchor_id_bindings_alignment_xreflabel_bindings_alignment
:END:
Vertically align =let= (and =let=-like) bindings.

#+begin_src clojure
;; good
(let [thing1 "some stuff"
      thing2 "other stuff"]
  (foo thing1 thing2))

;; bad
(let [thing1 "some stuff"
  thing2 "other stuff"]
  (foo thing1 thing2))
#+end_src

** Map Keys Alignment <<map-keys-alignment>>
:PROPERTIES:
:CUSTOM_ID: map_keys_alignment_anchor_id_map_keys_alignment_xreflabel_map_keys_alignment
:END:
Align vertically map keys.

#+begin_src clojure
;; good
{:thing1 thing1
 :thing2 thing2}

;; bad
{:thing1 thing1
:thing2 thing2}

;; bad
{:thing1 thing1
  :thing2 thing2}
#+end_src

** Line Endings <<crlf>>
:PROPERTIES:
:CUSTOM_ID: line_endings_anchor_id_crlf_xreflabel_crlf
:END:
Use Unix-style line endings.[fn:5]

If you're using Git you might want to add the following configuration
setting to protect your project from Windows line endings creeping in:

#+begin_example
$ git config --global core.autocrlf true
#+end_example

** Terminate Files With a Newline <<terminate-files-with-a-newline>>
:PROPERTIES:
:CUSTOM_ID: terminate_files_with_a_newline_anchor_id_terminate_files_with_a_newline_xreflabel_terminate_files_with_a_newline
:END:
End each file with a newline.

This should be done by through editor configuration, not manually.

** Bracket Spacing <<bracket-spacing>>
:PROPERTIES:
:CUSTOM_ID: bracket_spacing_anchor_id_bracket_spacing_xreflabel_bracket_spacing
:END:
If any text precedes an opening bracket(=(=, ={= and =[=) or follows a
closing bracket(=)=, =}= and =]=), separate that text from that bracket
with a space. Conversely, leave no space after an opening bracket and
before following text, or after preceding text and before a closing
bracket.

#+begin_src clojure
;; good
(foo (bar baz) quux)

;; bad
(foo(bar baz)quux)
(foo ( bar baz ) quux)
#+end_src

** No Commas in Sequential Collection Literals
<<no-commas-for-seq-literals>>
:PROPERTIES:
:CUSTOM_ID: no_commas_in_sequential_collection_literals_anchor_id_no_commas_for_seq_literals_xreflabel_no_commas_for_seq_literals
:END:

#+begin_quote
Syntactic sugar causes semicolon cancer.

---  Alan Perlis

#+end_quote

Don't use commas between the elements of sequential collection literals.

#+begin_src clojure
;; good
[1 2 3]
(1 2 3)

;; bad
[1, 2, 3]
(1, 2, 3)
#+end_src

** Optional Commas in Map Literals <<opt-commas-in-map-literals>>
:PROPERTIES:
:CUSTOM_ID: optional_commas_in_map_literals_anchor_id_opt_commas_in_map_literals_xreflabel_opt_commas_in_map_literals
:END:
Consider enhancing the readability of map literals via judicious use of
commas and line breaks.

#+begin_src clojure
;; good
{:name "Bruce Wayne" :alter-ego "Batman"}

;; good and arguably a bit more readable
{:name "Bruce Wayne"
 :alter-ego "Batman"}

;; good and arguably more compact
{:name "Bruce Wayne", :alter-ego "Batman"}
#+end_src

** Gather Trailing Parentheses <<gather-trailing-parens>>
:PROPERTIES:
:CUSTOM_ID: gather_trailing_parentheses_anchor_id_gather_trailing_parens_xreflabel_gather_trailing_parens
:END:
Place all trailing parentheses on a single line instead of distinct
lines.

#+begin_src clojure
;; good; single line
(when something
  (something-else))

;; bad; distinct lines
(when something
  (something-else)
)
#+end_src

** Empty Lines Between Top-Level Forms
<<empty-lines-between-top-level-forms>>
:PROPERTIES:
:CUSTOM_ID: empty_lines_between_top_level_forms_anchor_id_empty_lines_between_top_level_forms_xreflabel_empty_lines_between_top_level_forms
:END:
Use a single empty line between top-level forms.

#+begin_src clojure
;; good
(def x ...)

(defn foo ...)

;; bad
(def x ...)
(defn foo ...)

;; bad
(def x ...)


(defn foo ...)
#+end_src

An exception to the rule is the grouping of related ``def``s together.

#+begin_src clojure
;; good
(def min-rows 10)
(def max-rows 20)
(def min-cols 15)
(def max-cols 30)
#+end_src

** No Blank Lines Within Definition Forms
<<no-blank-lines-within-def-forms>>
:PROPERTIES:
:CUSTOM_ID: no_blank_lines_within_definition_forms_anchor_id_no_blank_lines_within_def_forms_xreflabel_no_blank_lines_within_def_forms
:END:
Do not place blank lines in the middle of a function or macro
definition. An exception can be made to indicate grouping of pairwise
constructs as found in e.g. =let= and =cond=, in case those don't fit on
the same line.

#+begin_src clojure
;; good
(defn fibo-iter
  ([n] (fibo-iter 0 1 n))
  ([curr nxt n]
   (cond
     (zero? n) curr
     :else (recur nxt (+' curr nxt) (dec n)))))

;; okay - the line break delimits a cond pair
(defn fibo-iter
  ([n] (fibo-iter 0 1 n))
  ([curr nxt n]
   (cond
     (zero? n)
     curr

     :else
     (recur nxt (+' curr nxt) (dec n)))))

;; bad
(defn fibo-iter
  ([n] (fibo-iter 0 1 n))

  ([curr nxt n]
   (cond
     (zero? n) curr

     :else (recur nxt (+' curr nxt) (dec n)))))
#+end_src

Occasionally, it might seem like a good idea to add a blank line here
and there in a longer function definition, but if you get to this point
you should also consider whether this long function isn't doing too much
and could potentially be broken down.

** No Trailing Whitespace <<no-trailing-whitespace>>
:PROPERTIES:
:CUSTOM_ID: no_trailing_whitespace_anchor_id_no_trailing_whitespace_xreflabel_no_trailing_whitespace
:END:
Avoid trailing whitespace.

** One File per Namespace <<one-file-per-namespace>>
:PROPERTIES:
:CUSTOM_ID: one_file_per_namespace_anchor_id_one_file_per_namespace_xreflabel_one_file_per_namespace
:END:
Use one file per namespace and one namespace per file.

#+begin_src clojure
;; good
(ns foo.bar)

;; bad
(ns foo.bar)
(ns baz.qux)

;; bad
(in-ns quux.quuz)
(in-ns quuz.corge)

;; bad
(ns foo.bar) or (in-ns foo.bar) in multiple files
#+end_src

* Namespace Declaration
:PROPERTIES:
:CUSTOM_ID: namespace_declaration
:END:
** No Single Segment Namespaces <<no-single-segment-namespaces>>
:PROPERTIES:
:CUSTOM_ID: no_single_segment_namespaces_anchor_id_no_single_segment_namespaces_xreflabel_no_single_segment_namespaces
:END:
Avoid single-segment namespaces.

#+begin_src clojure
;; good
(ns example.ns)

;; bad
(ns example)
#+end_src

Namespaces exist to disambiguate names. Using a single segment namespace
puts you in direct conflict with everyone else using single segment
namespaces, thus making it more likely you will conflict with another
code base.

In practice this means that libraries should never use single-segment
namespace to avoid namespace conflicts with other libraries. Within your
own private app of course, you can do whatever you like.

It's common practice to use the convention =domain.library-name= or
=library-name.core= for libraries with a single namespace in them. Read
on for more coverage of the namespace naming topic.

There are
[[https://github.com/bbatsov/clojure-style-guide/pull/100][other
reasons]] why might want to avoid single-segment namespaces, so you
should think long and hard before making any use of them.

** Namespace Segments Limit <<namespace-segments-limit>>
:PROPERTIES:
:CUSTOM_ID: namespace_segments_limit_anchor_id_namespace_segments_limit_xreflabel_namespace_segments_limit
:END:
Avoid the use of overly long namespaces (i.e., more than 5 segments).

** Comprehensive =ns= Form <<comprehensive-ns-declaration>>
:PROPERTIES:
:CUSTOM_ID: comprehensive_literal_ns_literal_form_anchor_id_comprehensive_ns_declaration_xreflabel_comprehensive_ns_declaration
:END:
Start every namespace with a comprehensive =ns= form, comprised of
``refer``s, ``require``s, and ``import``s, conventionally in that order.

#+begin_src clojure
(ns examples.ns
  (:refer-clojure :exclude [next replace remove])
  (:require [clojure.string :as s :refer [blank?]])
  (:import java.util.Date))
#+end_src

** Line Breaks in =ns= <<line-break-ns-declaration>>
:PROPERTIES:
:CUSTOM_ID: line_breaks_in_literal_ns_literal_anchor_id_line_break_ns_declaration_xreflabel_line_break_ns_declaration
:END:
When there are multiple dependencies, you may want give each one its own
line. This facilitates sorting, readability, and cleaner diffs for
dependency changes.

#+begin_src clojure
;; better
(ns examples.ns
  (:require
   [clojure.string :as s :refer [blank?]]
   [clojure.set :as set]
   [clojure.java.shell :as sh])
  (:import
   java.util.Date
   java.text.SimpleDateFormat
   [java.util.concurrent Executors
                         LinkedBlockingQueue]))

;; good
(ns examples.ns
  (:require [clojure.string :as s :refer [blank?]]
            [clojure.set :as set]
            [clojure.java.shell :as sh])
  (:import java.util.Date
           java.text.SimpleDateFormat
           [java.util.concurrent Executors
                                 LinkedBlockingQueue]))

;; bad
(ns examples.ns
  (:require [clojure.string :as s :refer [blank?]] [clojure.set :as set] [clojure.java.shell :as sh])
  (:import java.util.Date java.text.SimpleDateFormat [java.util.concurrent Executors LinkedBlockingQueue]))
#+end_src

** Prefer =:require= Over =:use= <<prefer-require-over-use>>
:PROPERTIES:
:CUSTOM_ID: prefer_literal_require_literal_over_literal_use_literal_anchor_id_prefer_require_over_use_xreflabel_prefer_require_over_use
:END:
In the =ns= form prefer =:require :as= over =:require :refer= over
=:require :refer :all=. Prefer =:require= over =:use=; the latter form
should be considered deprecated for new code.

#+begin_src clojure
;; good
(ns examples.ns
  (:require [clojure.zip :as zip]))

;; good
(ns examples.ns
  (:require [clojure.zip :refer [lefts rights]]))

;; acceptable as warranted
(ns examples.ns
  (:require [clojure.zip :refer :all]))

;; bad
(ns examples.ns
  (:use clojure.zip))
#+end_src

** Sort Requirements and Imports <<sort-requirements-and-imports>>
:PROPERTIES:
:CUSTOM_ID: sort_requirements_and_imports_anchor_id_sort_requirements_and_imports_xreflabel_sort_requirements_and_imports
:END:
In the =ns= form, sort your requirements and imports. This facilitates
readability and avoids duplication, especially when the list of required
/ imported namespaces is very long.

#+begin_src clojure
;; good
(ns examples.ns
  (:require
   [baz.core :as baz]
   [clojure.java.shell :as sh]
   [clojure.set :as set]
   [clojure.string :as s :refer [blank?]]
   [foo.bar :as foo]))

;; bad
(ns examples.ns
  (:require
   [clojure.string :as s :refer [blank?]]
   [clojure.set :as set]
   [baz.core :as baz]
   [foo.bar :as foo]
   [clojure.java.shell :as sh]))
#+end_src

** Use Idiomatic Namespace Aliases
:PROPERTIES:
:CUSTOM_ID: use_idiomatic_namespace_aliases
:END:
Many core Clojure namespaces have idiomatic aliases that you're
encouraged to use within your projects - e.g. the most common way to
require =clojure.string= is: =[clojure.string :as str]=.

This may appear to mask =clojure.core.str=, but it doesn't. It's
expected that =clojure.core/str= and =clojure.string/*= to be used in a
namespace as =str= and =str/whatever= without conflict.

#+begin_src clojure
;; good
(ns ... (:require [clojure.string :as str] ...)

(str/join ...)

;; not as good - just be idiomatic and use as `str/`
(ns ... (:require [clojure.string :as string] ...)

(string/join ...)
#+end_src

Some common, idiomatic aliases are shown below:

| Namespace             | Idiomatic Alias |
| clojure.edn           | edn             |
| clojure.java.io       | io              |
| clojure.java.shell    | sh              |
| clojure.math          | math            |
| clojure.pprint        | pp              |
| clojure.set           | set             |
| clojure.spec.alpha    | spec            |
| clojure.string        | str             |
| clojure.walk          | walk            |
| clojure.zip           | zip             |
| clojure.core.async    | as              |
| clojure.core.matrix   | mat             |
| clojure.data.csv      | csv             |
| clojure.data.xml      | xml             |
| clojure.tools.logging | log             |
| cheshire.core         | json            |
| clj-yaml.core         | yaml            |
| clj-http.client       | http            |
| hugsql.core           | sql             |
| java-time             | time            |

** A Recipe for Good Namespace Aliases
:PROPERTIES:
:CUSTOM_ID: a_recipe_for_good_namespace_aliases
:END:
Above we covered a handful of popular namespaces and their idiomatic
aliases. You might have noticed that those are a bit inconsistent:

- =clojure.string= becomes =str=

- =clojure.pprint= becomes =pp=

- =clojure.walk= becomes =walk=

- =clojure.spec.alpha= becomes =spec=

It's clear that the one thing they have in common is that they aim to be
concise, but still carry some meaning (aliasing =clojure.walk= to =w=
would be concise, but won't carry much meaning).

But what to do about all the other namespaces out there that don't have
idiomatic aliases? Well, you better be consistent in your approach to
deriving aliases for them, otherwise the people working on a shared
Clojure codebase are going to experience a great deal of confusion. Here
are a few rules that you should follow.[fn:6]

1. Make the alias the same as the namespace name with the leading parts
   removed.

#+begin_src clojure
(ns com.example.application
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string]))
#+end_src

1. Keep enough trailing parts to make each alias unique.

#+begin_src clojure
[clojure.data.xml :as data.xml]
[clojure.xml :as xml]
#+end_src

Yes, namespace aliases can have dots in them. Make good use of them.

1. Eliminate redundant words such as "core" and "clj" in aliases.

#+begin_src clojure
[clj-http :as http]
[clj-time.core :as time]
[clj-time.format :as time.format]
#+end_src

** Use Consistent Namespace Aliases
:PROPERTIES:
:CUSTOM_ID: use_consistent_namespace_aliases
:END:
Across a project, it's good to be consistent with namespace aliases;
e.g., don't require =clojure.string= as =str= in one namespace but
=string= in another. If you follow the previous two guidelines you're
basically covered, but if you opt for custom namespace aliasing scheme
it's still important to apply it consistently within your projects.

* Naming
:PROPERTIES:
:CUSTOM_ID: naming
:END:

#+begin_quote
The only real difficulties in programming are cache invalidation and
naming things.

---  Phil Karlton

#+end_quote

** Namespace Naming Schemas <<naming-ns-naming-schemas>>
:PROPERTIES:
:CUSTOM_ID: namespace_naming_schemas_anchor_id_naming_ns_naming_schemas_xreflabel_naming_ns_naming_schemas
:END:
When naming namespaces favor the following two schemas:

- =project.module=

- =organization.project.module=

When you're following the =project.module= naming scheme and your
project has a single (implementation) namespace it's common to name it
=project.core=. Avoid the =project.core= name in all other cases, as
more informative names are always a better idea.

** Composite Word Namespace Segments
<<naming-namespace-composite-segments>>
:PROPERTIES:
:CUSTOM_ID: composite_word_namespace_segments_anchor_id_naming_namespace_composite_segments_xreflabel_naming_namespace_composite_segments
:END:
Use =lisp-case= in composite namespace segments (e.g.
=bruce.project-euler=).

Many non-Lisp programming communities refer to =lisp-case= as
=kebab-case=, but we all know that Lisp existed way before kebab was
invented.

** Functions and Variables <<naming-functions-and-variables>>
:PROPERTIES:
:CUSTOM_ID: functions_and_variables_anchor_id_naming_functions_and_variables_xreflabel_naming_functions_and_variables
:END:
Use =lisp-case= for function and variable names.

#+begin_src clojure
;; good
(def some-var ...)
(defn some-fun ...)

;; bad
(def someVar ...)
(defn somefun ...)
(def some_fun ...)
#+end_src

** Protocols, Records, Structs and Types
<<naming-protocols-records-structs-and-types>>
:PROPERTIES:
:CUSTOM_ID: protocols_records_structs_and_types_anchor_id_naming_protocols_records_structs_and_types_xreflabel_naming_protocols_records_structs_and_types
:END:
Use =CapitalCase= for protocols, records, structs, and types. (Keep
acronyms like HTTP, RFC, XML uppercase.)

=CapitalCase= is also known as =UpperCamelCase, `CapitalWords= and
=PascalCase=.

** Predicate Methods <<naming-predicates>>
:PROPERTIES:
:CUSTOM_ID: predicate_methods_anchor_id_naming_predicates_xreflabel_naming_predicates
:END:
The names of predicate methods (methods that return a boolean value)
should end in a question mark (e.g., =even?=).

#+begin_src clojure
;; good
(defn palindrome? ...)

;; bad
(defn palindrome-p ...) ; Common Lisp style
(defn is-palindrome ...) ; Java style
#+end_src

** Unsafe Functions <<naming-unsafe-functions>>
:PROPERTIES:
:CUSTOM_ID: unsafe_functions_anchor_id_naming_unsafe_functions_xreflabel_naming_unsafe_functions
:END:
The names of functions/macros that are not safe in STM transactions
should end with an exclamation mark (e.g. =reset!=).

** Conversion Functions <<naming-conversion-functions>>
:PROPERTIES:
:CUSTOM_ID: conversion_functions_anchor_id_naming_conversion_functions_xreflabel_naming_conversion_functions
:END:
Use =+->+= instead of =to= in the names of conversion functions.

#+begin_src clojure
;; good
(defn f->c ...)

;; not so good
(defn f-to-c ...)
#+end_src

** Dynamic Vars <<naming-dynamic-vars>>
:PROPERTIES:
:CUSTOM_ID: dynamic_vars_anchor_id_naming_dynamic_vars_xreflabel_naming_dynamic_vars
:END:
Use =*earmuffs*= for things intended for rebinding (ie. are dynamic).

#+begin_src clojure
;; good
(def ^:dynamic *a* 10)

;; bad
(def ^:dynamic a 10)
#+end_src

** Constants <<naming-constants>>
:PROPERTIES:
:CUSTOM_ID: constants_anchor_id_naming_constants_xreflabel_naming_constants
:END:
Don't use a special notation for constants; everything is assumed a
constant unless specified otherwise.

#+begin_src clojure
;; good
(def max-size 10)

;; bad
(def MAX-SIZE 10) ; Java style
(def +max-size+ 10) ; Common Lisp style, global constant
(def *max-size* 10) ; Common Lisp style, global variable
#+end_src

Famously =\*clojure-version*= defies this convention, but you should
treat this naming choice as a historical oddity and not as an example to
follow.

** Unused Bindings <<naming-unused-bindings>>
:PROPERTIES:
:CUSTOM_ID: unused_bindings_anchor_id_naming_unused_bindings_xreflabel_naming_unused_bindings
:END:
Use =+_+= for destructuring targets and formal argument names whose
value will be ignored by the code at hand.

#+begin_src clojure
;; good
(let [[a b _ c] [1 2 3 4]]
  (println a b c))

(dotimes [_ 3]
  (println "Hello!"))

;; bad
(let [[a b c d] [1 2 3 4]]
  (println a b d))

(dotimes [i 3]
  (println "Hello!"))
#+end_src

However, when it can help the understanding of your code, it can be
useful to explicitly name unused arguments or maps you're destructuring
from. In this case, prepend the name with an underscore to explicitly
signal that the variable is supposed to be unused.

#+begin_src clojure
;; good
(defn myfun1 [context _]
 (assoc context :foo "bar"))

(defn myfun2 [context {:keys [id]}]
 (assoc context :user-id id))

;; better
(defn myfun1 [context _user]
 (assoc context :foo "bar"))

(defn myfun2 [context {:keys [id] :as _user}]
 (assoc context :user-id id))
#+end_src

** Idiomatic Names <<idiomatic-names>>
:PROPERTIES:
:CUSTOM_ID: idiomatic_names_anchor_id_idiomatic_names_xreflabel_idiomatic_names
:END:
Follow ``clojure.core``'s example for idiomatic names like =pred= and
=coll=.

- in functions:

  - =f=, =g=, =h= - function input

  - =n= - integer input usually a size

  - =index=, =i= - integer index

  - =x=, =y= - numbers

  - =xs= - sequence

  - =m= - map

  - =s= - string input

  - =re= - regular expression

  - =sym= - symbol

  - =coll= - a collection

  - =pred= - a predicate closure

  - =& more= - variadic input

  - =xf= - xform, a transducer

  - =ns= - namespace[fn:7]

- in macros:

  - =expr= - an expression

  - =body= - a macro body

  - =binding= - a macro binding vector

- in methods (when specified in =defprotocol=, =deftype=, =defrecord=,
  =reify=, etc):

  - =this= - for the first argument, indicating a reference to the
    object - or alternatively, a consistent name which describes the
    object

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:END:
** Optional New Line After Function Name
<<optional-new-line-after-fn-name>>
:PROPERTIES:
:CUSTOM_ID: optional_new_line_after_function_name_anchor_id_optional_new_line_after_fn_name_xreflabel_optional_new_line_after_fn_name
:END:
Optionally omit the new line between the function name and argument
vector for =defn= when there is no docstring.

#+begin_src clojure
;; good
(defn foo
  [x]
  (bar x))

;; good
(defn foo [x]
  (bar x))

;; bad
(defn foo
  [x] (bar x))
#+end_src

** Multimethod Dispatch Val Placement
<<multimethod-dispatch-val-placement>>
:PROPERTIES:
:CUSTOM_ID: multimethod_dispatch_val_placement_anchor_id_multimethod_dispatch_val_placement_xreflabel_multimethod_dispatch_val_placement
:END:
Place the =dispatch-val= of a multimethod on the same line as the
function name.

#+begin_src clojure
;; good
(defmethod foo :bar [x] (baz x))

(defmethod foo :bar
  [x]
  (baz x))

;; bad
(defmethod foo
  :bar
  [x]
  (baz x))

(defmethod foo
  :bar [x]
  (baz x))
#+end_src

** One-line Functions
:PROPERTIES:
:CUSTOM_ID: one_line_functions
:END:
Optionally omit the new line between the argument vector and a short
function body.

#+begin_src clojure
;; good
(defn foo [x]
  (bar x))

;; good for a small function body
(defn foo [x] (bar x))

;; good for multi-arity functions
(defn foo
  ([x] (bar x))
  ([x y]
   (if (predicate? x)
     (bar x)
     (baz x))))

;; bad
(defn foo
  [x] (if (predicate? x)
        (bar x)
        (baz x)))
#+end_src

** Multiple Arity Indentation <<multiple-arity-indentation>>
:PROPERTIES:
:CUSTOM_ID: multiple_arity_indentation_anchor_id_multiple_arity_indentation_xreflabel_multiple_arity_indentation
:END:
Indent each arity form of a function definition vertically aligned with
its parameters.

#+begin_src clojure
;; good
(defn foo
  "I have two arities."
  ([x]
   (foo x 1))
  ([x y]
   (+ x y)))

;; bad - extra indentation
(defn foo
  "I have two arities."
  ([x]
    (foo x 1))
  ([x y]
    (+ x y)))
#+end_src

** Multiple Arity Order <<multiple-arity-order>>
:PROPERTIES:
:CUSTOM_ID: multiple_arity_order_anchor_id_multiple_arity_order_xreflabel_multiple_arity_order
:END:
Sort the arities of a function from fewest to most arguments. The common
case of multi-arity functions is that some K arguments fully specifies
the function's behavior, and that arities N < K partially apply the K
arity, and arities N > K provide a fold of the K arity over varargs.

#+begin_src clojure
;; good - it's easy to scan for the nth arity
(defn foo
  "I have two arities."
  ([x]
   (foo x 1))
  ([x y]
   (+ x y)))

;; okay - the other arities are applications of the two-arity
(defn foo
  "I have two arities."
  ([x y]
   (+ x y))
  ([x]
   (foo x 1))
  ([x y z & more]
   (reduce foo (foo x (foo y z)) more)))

;; bad - unordered for no apparent reason
(defn foo
  ([x] 1)
  ([x y z] (foo x (foo y z)))
  ([x y] (+ x y))
  ([w x y z & more] (reduce foo (foo w (foo x (foo y z))) more)))
#+end_src

** Function Length <<function-length>>
:PROPERTIES:
:CUSTOM_ID: function_length_anchor_id_function_length_xreflabel_function_length
:END:
Avoid functions longer than 10 LOC (lines of code). Ideally, most
functions will be shorter than 5 LOC.

** Function Positional Parameters Limit
<<function-positional-parameter-limit>>
:PROPERTIES:
:CUSTOM_ID: function_positional_parameters_limit_anchor_id_function_positional_parameter_limit_xreflabel_function_positional_parameter_limit
:END:
Avoid parameter lists with more than three or four positional
parameters.

** Pre and Post Conditions <<pre-post-conditions>>
:PROPERTIES:
:CUSTOM_ID: pre_and_post_conditions_anchor_id_pre_post_conditions_xreflabel_pre_post_conditions
:END:
Prefer function pre and post conditions to checks inside a function's
body.

#+begin_src clojure
;; good
(defn foo [x]
  {:pre [(pos? x)]}
  (bar x))

;; bad
(defn foo [x]
  (if (pos? x)
    (bar x)
    (throw (IllegalArgumentException. "x must be a positive number!")))
#+end_src

* Idioms
:PROPERTIES:
:CUSTOM_ID: idioms
:END:
** Dynamic Namespace Manipulation <<ns-fns-only-in-repl>>
:PROPERTIES:
:CUSTOM_ID: dynamic_namespace_manipulation_anchor_id_ns_fns_only_in_repl_xreflabel_ns_fns_only_in_repl
:END:
Avoid the use of namespace-manipulating functions like =require= and
=refer=. They are entirely unnecessary outside of a REPL environment.

** Forward References <<forward-references>>
:PROPERTIES:
:CUSTOM_ID: forward_references_anchor_id_forward_references_xreflabel_forward_references
:END:
Avoid forward references. They are occasionally necessary, but such
occasions are rare in practice.

** Declare <<declare>>
:PROPERTIES:
:CUSTOM_ID: declare_anchor_id_declare_xreflabel_declare
:END:
Use =declare= to enable forward references when forward references are
necessary.

** Higher-order Functions <<higher-order-fns>>
:PROPERTIES:
:CUSTOM_ID: higher_order_functions_anchor_id_higher_order_fns_xreflabel_higher_order_fns
:END:
Prefer higher-order functions like =map= to =loop/recur=.

** Vars Inside Functions <<dont-def-vars-inside-fns>>
:PROPERTIES:
:CUSTOM_ID: vars_inside_functions_anchor_id_dont_def_vars_inside_fns_xreflabel_dont_def_vars_inside_fns
:END:
Don't define vars inside functions.

#+begin_src clojure
;; very bad
(defn foo []
  (def x 5)
  ...)
#+end_src

** Shadowing =clojure.core= Names <<dont-shadow-clojure-core>>
:PROPERTIES:
:CUSTOM_ID: shadowing_literal_clojure_core_literal_names_anchor_id_dont_shadow_clojure_core_xreflabel_dont_shadow_clojure_core
:END:
Don't shadow =clojure.core= names with local bindings.

#+begin_src clojure
;; bad - clojure.core/map must be fully qualified inside the function
(defn foo [map]
  ...)
#+end_src

** Alter Var Binding <<alter-var>>
:PROPERTIES:
:CUSTOM_ID: alter_var_binding_anchor_id_alter_var_xreflabel_alter_var
:END:
Use =alter-var-root= instead of =def= to change the value of a var.

#+begin_src clojure
;; good
(def thing 1) ; value of thing is now 1
; do some stuff with thing
(alter-var-root #'thing (constantly nil)) ; value of thing is now nil

;; bad
(def thing 1)
; do some stuff with thing
(def thing nil)
; value of thing is now nil
#+end_src

** Nil Punning <<nil-punning>>
:PROPERTIES:
:CUSTOM_ID: nil_punning_anchor_id_nil_punning_xreflabel_nil_punning
:END:
Use =seq= as a terminating condition to test whether a sequence is empty
(this technique is sometimes called /nil punning/).

#+begin_src clojure
;; good
(defn print-seq [s]
  (when (seq s)
    (prn (first s))
    (recur (rest s))))

;; bad
(defn print-seq [s]
  (when-not (empty? s)
    (prn (first s))
    (recur (rest s))))
#+end_src

** Converting Sequences to Vectors <<to-vector>>
:PROPERTIES:
:CUSTOM_ID: converting_sequences_to_vectors_anchor_id_to_vector_xreflabel_to_vector
:END:
Prefer =vec= over =into= when you need to convert a sequence into a
vector.

#+begin_src clojure
;; good
(vec some-seq)

;; bad
(into [] some-seq)
#+end_src

** Converting Something to Boolean
:PROPERTIES:
:CUSTOM_ID: converting_something_to_boolean
:END:
Use the =boolean= function if you need to convert something to an actual
boolean value (=true= or =false=).

#+begin_src clojure
;; good
(boolean (foo bar))

;; bad
(if (foo bar) true false)
#+end_src

Don't forget that the only values in Clojure that are "falsey" are
=false= and =nil=. Everything else will evaluate to =true= when passed
to the =boolean= function.

You'll rarely need an actual boolean value in Clojure, but it's useful
to know how to obtain one when you do.

** =when= vs =if= <<when-instead-of-single-branch-if>>
:PROPERTIES:
:CUSTOM_ID: literal_when_literal_vs_literal_if_literal_anchor_id_when_instead_of_single_branch_if_xreflabel_when_instead_of_single_branch_if
:END:
Use =when= instead of =if= with just the truthy branch, as in
=(if condition (something...))= or =(if ... (do ...))=.

#+begin_src clojure
;; good
(when pred
  (foo)
  (bar))

;; bad
(if pred
  (do
    (foo)
    (bar)))
#+end_src

** =if-let= <<if-let>>
:PROPERTIES:
:CUSTOM_ID: literal_if_let_literal_anchor_id_if_let_xreflabel_if_let
:END:
Use =if-let= instead of =let= + =if=.

#+begin_src clojure
;; good
(if-let [result (foo x)]
  (something-with result)
  (something-else))

;; bad
(let [result (foo x)]
  (if result
    (something-with result)
    (something-else)))
#+end_src

** =when-let= <<when-let>>
:PROPERTIES:
:CUSTOM_ID: literal_when_let_literal_anchor_id_when_let_xreflabel_when_let
:END:
Use =when-let= instead of =let= + =when=.

#+begin_src clojure
;; good
(when-let [result (foo x)]
  (do-something-with result)
  (do-something-more-with result))

;; bad
(let [result (foo x)]
  (when result
    (do-something-with result)
    (do-something-more-with result)))
#+end_src

** =if-not= <<if-not>>
:PROPERTIES:
:CUSTOM_ID: literal_if_not_literal_anchor_id_if_not_xreflabel_if_not
:END:
Use =if-not= instead of =(if (not ...) ...)=.

#+begin_src clojure
;; good
(if-not pred
  (foo))

;; bad
(if (not pred)
  (foo))
#+end_src

** =when-not= <<when-not>>
:PROPERTIES:
:CUSTOM_ID: literal_when_not_literal_anchor_id_when_not_xreflabel_when_not
:END:
Use =when-not= instead of =(when (not ...) ...)=.

#+begin_src clojure
;; good
(when-not pred
  (foo)
  (bar))

;; bad
(when (not pred)
  (foo)
  (bar))
#+end_src

** =when-not= vs =if-not= <<when-not-instead-of-single-branch-if-not>>
:PROPERTIES:
:CUSTOM_ID: literal_when_not_literal_vs_literal_if_not_literal_anchor_id_when_not_instead_of_single_branch_if_not_xreflabel_when_not_instead_of_single_branch_if_not
:END:
Use =when-not= instead of =(if-not ... (do ...))=.

#+begin_src clojure
;; good
(when-not pred
  (foo)
  (bar))

;; bad
(if-not pred
  (do
    (foo)
    (bar)))
#+end_src

** =not== <<not-equal>>
:PROPERTIES:
:CUSTOM_ID: literal_not_literal_anchor_id_not_equal_xreflabel_not_equal
:END:
Use =not== instead of =(not (= ...))=.

#+begin_src clojure
;; good
(not= foo bar)

;; bad
(not (= foo bar))
#+end_src

** =printf= <<printf>>
:PROPERTIES:
:CUSTOM_ID: literal_printf_literal_anchor_id_printf_xreflabel_printf
:END:
Prefer =printf= over =(print (format ...))=.

#+begin_src clojure
;; good
(printf "Hello, %s!\n" name)

;; ok
(println (format "Hello, %s!" name))
#+end_src

** Flexible Comparison Functions
:PROPERTIES:
:CUSTOM_ID: flexible_comparison_functions
:END:
When doing comparisons, leverage the fact that Clojure's functions =<=,
=>=, etc. accept a variable number of arguments.

#+begin_src clojure
;; good
(< 5 x 10)

;; bad
(and (> x 5) (< x 10))
#+end_src

** Single Parameter Function Literal <<single-param-fn-literal>>
:PROPERTIES:
:CUSTOM_ID: single_parameter_function_literal_anchor_id_single_param_fn_literal_xreflabel_single_param_fn_literal
:END:
Prefer =%= over =%1= in function literals with only one parameter.

#+begin_src clojure
;; good
#(Math/round %)

;; bad
#(Math/round %1)
#+end_src

** Multiple Parameters Function Literal <<multiple-params-fn-literal>>
:PROPERTIES:
:CUSTOM_ID: multiple_parameters_function_literal_anchor_id_multiple_params_fn_literal_xreflabel_multiple_params_fn_literal
:END:
Prefer =%1= over =%= in function literals with more than one parameter.

#+begin_src clojure
;; good
#(Math/pow %1 %2)

;; bad
#(Math/pow % %2)
#+end_src

** No Useless Anonymous Functions <<no-useless-anonymous-fns>>
:PROPERTIES:
:CUSTOM_ID: no_useless_anonymous_functions_anchor_id_no_useless_anonymous_fns_xreflabel_no_useless_anonymous_fns
:END:
Don't wrap functions in anonymous functions when you don't need to.

#+begin_src clojure
;; good
(filter even? (range 1 10))

;; bad
(filter #(even? %) (range 1 10))
#+end_src

** No Multiple Forms in Function Literals
<<no-multiple-forms-fn-literals>>
:PROPERTIES:
:CUSTOM_ID: no_multiple_forms_in_function_literals_anchor_id_no_multiple_forms_fn_literals_xreflabel_no_multiple_forms_fn_literals
:END:
Don't use function literals if the function body will consist of more
than one form.

#+begin_src clojure
;; good
(fn [x]
  (println x)
  (* x 2))

;; bad (you need an explicit do form)
#(do (println %)
     (* % 2))
#+end_src

** Anonymous Functions vs =complement=, =comp= and =partial=
:PROPERTIES:
:CUSTOM_ID: anonymous_functions_vs_literal_complement_literal_literal_comp_literal_and_literal_partial_literal
:END:
Prefer anonymous functions over =complement=, =comp= and =partial=, as
this results in simpler code most of the time.[fn:8]

*** =complement= <<complement>>
:PROPERTIES:
:CUSTOM_ID: literal_complement_literal_anchor_id_complement_xreflabel_complement
:END:
#+begin_src clojure
;; good
(filter #(not (some-pred? %)) coll)

;; okish
(filter (complement some-pred?) coll)
#+end_src

*** =comp= <<comp>>
:PROPERTIES:
:CUSTOM_ID: literal_comp_literal_anchor_id_comp_xreflabel_comp
:END:
#+begin_src clojure
;; Assuming `(:require [clojure.string :as str])`...

;; good
(map #(str/capitalize (str/trim %)) ["top " " test "])

;; okish
(map (comp str/capitalize str/trim) ["top " " test "])
#+end_src

=comp= is quite useful when composing transducer chains, though.

#+begin_src clojure
;; good
(def xf
  (comp
    (filter odd?)
    (map inc)
    (take 5)))
#+end_src

*** =partial= <<partial>>
:PROPERTIES:
:CUSTOM_ID: literal_partial_literal_anchor_id_partial_xreflabel_partial
:END:
#+begin_src clojure
;; good
(map #(+ 5 %) (range 1 10))

;; okish
(map (partial + 5) (range 1 10))
#+end_src

** Threading Macros <<threading-macros>>
:PROPERTIES:
:CUSTOM_ID: threading_macros_anchor_id_threading_macros_xreflabel_threading_macros
:END:
Prefer the use of the threading macros =+->+= (thread-first) and =+->>+=
(thread-last) to heavy form nesting.

#+begin_src clojure
;; good
(-> [1 2 3]
    reverse
    (conj 4)
    prn)

;; not as good
(prn (conj (reverse [1 2 3])
           4))

;; good
(->> (range 1 10)
     (filter even?)
     (map (partial * 2)))

;; not as good
(map (partial * 2)
     (filter even? (range 1 10)))
#+end_src

** Threading Macros and Optional Parentheses
:PROPERTIES:
:CUSTOM_ID: threading_macros_and_optional_parentheses
:END:
Parentheses are not required when using the threading macros for
functions having no argument specified, so use them only when necessary.

#+begin_src clojure
;; good
(-> x fizz :foo first frob)

;; bad; parens add clutter and are not needed
(-> x (fizz) (:foo) (first) (frob))

;; good, parens are necessary with an arg
(-> x
    (fizz a b)
    :foo
    first
    (frob x y))
#+end_src

** Threading Macros Alignment
:PROPERTIES:
:CUSTOM_ID: threading_macros_alignment
:END:
The arguments to the threading macros =+->+= (thread-first) and =+->>+=
(thread-last) should line up.

#+begin_src clojure
;; good
(->> (range)
     (filter even?)
     (take 5))

;; bad
(->> (range)
  (filter even?)
  (take 5))
#+end_src

** Default =cond= Branch <<else-keyword-in-cond>>
:PROPERTIES:
:CUSTOM_ID: default_literal_cond_literal_branch_anchor_id_else_keyword_in_cond_xreflabel_else_keyword_in_cond
:END:
Use =:else= as the catch-all test expression in =cond=.

#+begin_src clojure
;; good
(cond
  (neg? n) "negative"
  (pos? n) "positive"
  :else "zero")

;; bad
(cond
  (neg? n) "negative"
  (pos? n) "positive"
  true "zero")
#+end_src

** =condp= vs =cond= <<condp>>
:PROPERTIES:
:CUSTOM_ID: literal_condp_literal_vs_literal_cond_literal_anchor_id_condp_xreflabel_condp
:END:
Prefer =condp= instead of =cond= when the predicate & expression don't
change.

#+begin_src clojure
;; good
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :thirty
  :else :dunno)

;; much better
(condp = x
  10 :ten
  20 :twenty
  30 :thirty
  :dunno)
#+end_src

** =case= vs =cond/condp= <<case>>
:PROPERTIES:
:CUSTOM_ID: literal_case_literal_vs_literal_cond_condp_literal_anchor_id_case_xreflabel_case
:END:
Prefer =case= instead of =cond= or =condp= when test expressions are
compile-time constants.

#+begin_src clojure
;; good
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :forty
  :else :dunno)

;; better
(condp = x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)

;; best
(case x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)
#+end_src

** Short Forms In Cond <<short-forms-in-cond>>
:PROPERTIES:
:CUSTOM_ID: short_forms_in_cond_anchor_id_short_forms_in_cond_xreflabel_short_forms_in_cond
:END:
Use short forms in =cond= and related. If not possible give visual hints
for the pairwise grouping with comments or empty lines.

#+begin_src clojure
;; good
(cond
  (test1) (action1)
  (test2) (action2)
  :else   (default-action))

;; ok-ish
(cond
  ;; test case 1
  (test1)
  (long-function-name-which-requires-a-new-line
    (complicated-sub-form
      (-> 'which-spans multiple-lines)))

  ;; test case 2
  (test2)
  (another-very-long-function-name
    (yet-another-sub-form
      (-> 'which-spans multiple-lines)))

  :else
  (the-fall-through-default-case
    (which-also-spans 'multiple
                      'lines)))
#+end_src

** Set As Predicate <<set-as-predicate>>
:PROPERTIES:
:CUSTOM_ID: set_as_predicate_anchor_id_set_as_predicate_xreflabel_set_as_predicate
:END:
Use a =set= as a predicate when appropriate.

#+begin_src clojure
;; good
(remove #{1} [0 1 2 3 4 5])

;; bad
(remove #(= % 1) [0 1 2 3 4 5])

;; good
(count (filter #{\a \e \i \o \u} "mary had a little lamb"))

;; bad
(count (filter #(or (= % \a)
                    (= % \e)
                    (= % \i)
                    (= % \o)
                    (= % \u))
               "mary had a little lamb"))
#+end_src

** =inc= and =dec= <<inc-and-dec>>
:PROPERTIES:
:CUSTOM_ID: literal_inc_literal_and_literal_dec_literal_anchor_id_inc_and_dec_xreflabel_inc_and_dec
:END:
Use =(inc x)= & =(dec x)= instead of =(+ x 1)= and =(- x 1)=.

** =pos?= and =neg?= <<pos-and-neg>>
:PROPERTIES:
:CUSTOM_ID: literal_pos_literal_and_literal_neg_literal_anchor_id_pos_and_neg_xreflabel_pos_and_neg
:END:
Use =(pos? x)=, =(neg? x)= & =(zero? x)= instead of =(> x 0)=, =(< x 0)=
& =(= x 0)=.

** =list*= vs =cons= <<list-star-instead-of-nested-cons>>
:PROPERTIES:
:CUSTOM_ID: literal_list_literal_vs_literal_cons_literal_anchor_id_list_star_instead_of_nested_cons_xreflabel_list_star_instead_of_nested_cons
:END:
Use =list*= instead of a series of nested =cons= invocations.

#+begin_src clojure
;; good
(list* 1 2 3 [4 5])

;; bad
(cons 1 (cons 2 (cons 3 [4 5])))
#+end_src

** Sugared Java Interop <<sugared-java-interop>>
:PROPERTIES:
:CUSTOM_ID: sugared_java_interop_anchor_id_sugared_java_interop_xreflabel_sugared_java_interop
:END:
Use the sugared Java interop forms.

#+begin_src clojure
;;; object creation
;; good
(java.util.ArrayList. 100)

;; bad
(new java.util.ArrayList 100)

;;; static method invocation
;; good
(Math/pow 2 10)

;; bad
(. Math pow 2 10)

;;; instance method invocation
;; good
(.substring "hello" 1 3)

;; bad
(. "hello" substring 1 3)

;;; static field access
;; good
Integer/MAX_VALUE

;; bad
(. Integer MAX_VALUE)

;;; instance field access
;; good
(.someField some-object)

;; bad
(. some-object someField)
#+end_src

** Compact Metadata Notation For True Flags
<<compact-metadata-notation-for-true-flags>>
:PROPERTIES:
:CUSTOM_ID: compact_metadata_notation_for_true_flags_anchor_id_compact_metadata_notation_for_true_flags_xreflabel_compact_metadata_notation_for_true_flags
:END:
Use the compact metadata notation for metadata that contains only slots
whose keys are keywords and whose value is boolean =true=.

#+begin_src clojure
;; good
(def ^:private a 5)

;; bad
(def ^{:private true} a 5)
#+end_src

** Private <<private>>
:PROPERTIES:
:CUSTOM_ID: private_anchor_id_private_xreflabel_private
:END:
Denote private parts of your code.

#+begin_src clojure
;; good
(defn- private-fun [] ...)

(def ^:private private-var ...)

;; bad
(defn private-fun [] ...) ; not private at all

(defn ^:private private-fun [] ...) ; overly verbose

(def private-var ...) ; not private at all
#+end_src

** Access Private Var <<access-private-var>>
:PROPERTIES:
:CUSTOM_ID: access_private_var_anchor_id_access_private_var_xreflabel_access_private_var
:END:
To access a private var (e.g. for testing), use the =@#'some.ns/var=
form.

** Attach Metadata Carefully <<attach-metadata-carefully>>
:PROPERTIES:
:CUSTOM_ID: attach_metadata_carefully_anchor_id_attach_metadata_carefully_xreflabel_attach_metadata_carefully
:END:
Be careful regarding what exactly you attach metadata to.

#+begin_src clojure
;; we attach the metadata to the var referenced by `a`
(def ^:private a {})
(meta a) ;=> nil
(meta #'a) ;=> {:private true}

;; we attach the metadata to the empty hash-map value
(def a ^:private {})
(meta a) ;=> {:private true}
(meta #'a) ;=> nil
#+end_src

* Data Structures
:PROPERTIES:
:CUSTOM_ID: data_structures
:END:

#+begin_quote
It is better to have 100 functions operate on one data structure than to
have 10 functions operate on 10 data structures.

---  Alan J. Perlis

#+end_quote

** Avoid Lists <<avoid-lists>>
:PROPERTIES:
:CUSTOM_ID: avoid_lists_anchor_id_avoid_lists_xreflabel_avoid_lists
:END:
Avoid the use of lists for generic data storage (unless a list is
exactly what you need).

** Keywords For Hash Keys <<keywords-for-hash-keys>>
:PROPERTIES:
:CUSTOM_ID: keywords_for_hash_keys_anchor_id_keywords_for_hash_keys_xreflabel_keywords_for_hash_keys
:END:
Prefer the use of keywords for hash keys.

#+begin_src clojure
;; good
{:name "Bruce" :age 30}

;; bad
{"name" "Bruce" "age" 30}
#+end_src

** Literal Collection Syntax <<literal-col-syntax>>
:PROPERTIES:
:CUSTOM_ID: literal_collection_syntax_anchor_id_literal_col_syntax_xreflabel_literal_col_syntax
:END:
Prefer the use of the literal collection syntax where applicable.
However, when defining sets, only use literal syntax when the values are
compile-time constants.

#+begin_src clojure
;; good
[1 2 3]
#{1 2 3}
(hash-set (func1) (func2)) ; values determined at runtime

;; bad
(vector 1 2 3)
(hash-set 1 2 3)
#{(func1) (func2)} ; will throw runtime exception if (func1) = (func2)
#+end_src

** Avoid Index Based Collection Access <<avoid-index-based-coll-access>>
:PROPERTIES:
:CUSTOM_ID: avoid_index_based_collection_access_anchor_id_avoid_index_based_coll_access_xreflabel_avoid_index_based_coll_access
:END:
Avoid accessing collection members by index whenever possible.

** Keywords as Functions for Map Values Retrieval
<<keywords-as-fn-to-get-map-values>>
:PROPERTIES:
:CUSTOM_ID: keywords_as_functions_for_map_values_retrieval_anchor_id_keywords_as_fn_to_get_map_values_xreflabel_keywords_as_fn_to_get_map_values
:END:
Prefer the use of keywords as functions for retrieving values from maps,
where applicable.

#+begin_src clojure
(def m {:name "Bruce" :age 30})

;; good
(:name m)

;; more verbose than necessary
(get m :name)

;; bad - susceptible to NullPointerException
(m :name)
#+end_src

** Collections as Functions <<colls-as-fns>>
:PROPERTIES:
:CUSTOM_ID: collections_as_functions_anchor_id_colls_as_fns_xreflabel_colls_as_fns
:END:
Leverage the fact that most collections are functions of their elements.

#+begin_src clojure
;; good
(filter #{\a \e \o \i \u} "this is a test")

;; bad - too ugly to share
#+end_src

** Keywords as Functions <<keywords-as-fns>>
:PROPERTIES:
:CUSTOM_ID: keywords_as_functions_anchor_id_keywords_as_fns_xreflabel_keywords_as_fns
:END:
Leverage the fact that keywords can be used as functions of a
collection.

#+begin_src clojure
((juxt :a :b) {:a "ala" :b "bala"})
#+end_src

** Avoid Transient Collections <<avoid-transient-colls>>
:PROPERTIES:
:CUSTOM_ID: avoid_transient_collections_anchor_id_avoid_transient_colls_xreflabel_avoid_transient_colls
:END:
Avoid the use of transient collections, except for performance-critical
portions of the code.

** Avoid Java Collections <<avoid-java-colls>>
:PROPERTIES:
:CUSTOM_ID: avoid_java_collections_anchor_id_avoid_java_colls_xreflabel_avoid_java_colls
:END:
Avoid the use of Java collections.

** Avoid Java Arrays <<avoid-java-arrays>>
:PROPERTIES:
:CUSTOM_ID: avoid_java_arrays_anchor_id_avoid_java_arrays_xreflabel_avoid_java_arrays
:END:
Avoid the use of Java arrays, except for interop scenarios and
performance-critical code dealing heavily with primitive types.

* Types & Records
:PROPERTIES:
:CUSTOM_ID: types_amp_records
:END:
** Record Constructors <<record-constructors>>
:PROPERTIES:
:CUSTOM_ID: record_constructors_anchor_id_record_constructors_xreflabel_record_constructors
:END:
Don't use the interop syntax to construct type and record instances.
=deftype= and =defrecord= automatically create constructor functions.
Use those instead of the interop syntax, as they make it clear that
you're dealing with a =deftype= or a =defrecord=. See
[[https://stuartsierra.com/2015/05/17/clojure-record-constructors][this
article]] for more details.

#+begin_src clojure
(defrecord Foo [a b])
(deftype Bar [a b])

;; good
(->Foo 1 2)
(map->Foo {:b 4 :a 3})
(->Bar 1 2)

;; bad
(Foo. 1 2)
(Bar. 1 2)
#+end_src

Note that =deftype= doesn't define the =+map->Type+= constructor. It's
available only for records.

** Custom Record Constructors <<custom-record-constructors>>
:PROPERTIES:
:CUSTOM_ID: custom_record_constructors_anchor_id_custom_record_constructors_xreflabel_custom_record_constructors
:END:
Add custom type/record constructors when needed (e.g. to validate
properties on record creation). See
[[https://stuartsierra.com/2015/05/17/clojure-record-constructors][this
article]] for more details.

#+begin_src clojure
(defrecord Customer [id name phone email])

(defn make-customer
  "Creates a new customer record."
  [{:keys [name phone email]}]
  {:pre [(string? name)
         (valid-phone? phone)
         (valid-email? email)]}
  (->Customer (next-id) name phone email))
#+end_src

Feel free to adopt whatever naming convention or structure you'd like
for such custom constructors.

** Custom Record Constructors Naming
<<custom-record-constructors-naming>>
:PROPERTIES:
:CUSTOM_ID: custom_record_constructors_naming_anchor_id_custom_record_constructors_naming_xreflabel_custom_record_constructors_naming
:END:
Don't override the auto-generated type/record constructor functions.
People expect them to have a certain behaviour and changing this
behaviour violates the principle of least surprise. See
[[https://stuartsierra.com/2015/05/17/clojure-record-constructors][this
article]] for more details.

#+begin_src clojure
(defrecord Foo [num])

;; good
(defn make-foo
  [num]
  {:pre [(pos? num)]}
  (->Foo num))

;; bad
(defn ->Foo
  [num]
  {:pre [(pos? num)]}
  (Foo. num))
#+end_src

* Mutation
:PROPERTIES:
:CUSTOM_ID: mutation
:END:
** Refs <<Refs>>
:PROPERTIES:
:CUSTOM_ID: refs_anchor_id_refs_xreflabel_refs
:END:
*** =io!= Macro <<refs-io-macro>>
:PROPERTIES:
:CUSTOM_ID: literal_io_literal_macro_anchor_id_refs_io_macro_xreflabel_refs_io_macro
:END:
Consider wrapping all I/O calls with the =io!= macro to avoid nasty
surprises if you accidentally end up calling such code in a transaction.

*** Avoid =ref-set= <<refs-avoid-ref-set>>
:PROPERTIES:
:CUSTOM_ID: avoid_literal_ref_set_literal_anchor_id_refs_avoid_ref_set_xreflabel_refs_avoid_ref_set
:END:
Avoid the use of =ref-set= whenever possible.

#+begin_src clojure
(def r (ref 0))

;; good
(dosync (alter r + 5))

;; bad
(dosync (ref-set r 5))
#+end_src

*** Small Transactions <<refs-small-transactions>>
:PROPERTIES:
:CUSTOM_ID: small_transactions_anchor_id_refs_small_transactions_xreflabel_refs_small_transactions
:END:
Try to keep the size of transactions (the amount of work encapsulated in
them) as small as possible.

*** Avoid Short Long Transactions With Same Ref
<<refs-avoid-short-long-transactions-with-same-ref>>
:PROPERTIES:
:CUSTOM_ID: avoid_short_long_transactions_with_same_ref_anchor_id_refs_avoid_short_long_transactions_with_same_ref_xreflabel_refs_avoid_short_long_transactions_with_same_ref
:END:
Avoid having both short- and long-running transactions interacting with
the same Ref.

** Agents <<Agents>>
:PROPERTIES:
:CUSTOM_ID: agents_anchor_id_agents_xreflabel_agents
:END:
*** Agents Send <<agents-send>>
:PROPERTIES:
:CUSTOM_ID: agents_send_anchor_id_agents_send_xreflabel_agents_send
:END:
Use =send= only for actions that are CPU bound and don't block on I/O or
other threads.

*** Agents Send Off <<agents-send-off>>
:PROPERTIES:
:CUSTOM_ID: agents_send_off_anchor_id_agents_send_off_xreflabel_agents_send_off
:END:
Use =send-off= for actions that might block, sleep, or otherwise tie up
the thread.

** Atoms <<Atoms>>
:PROPERTIES:
:CUSTOM_ID: atoms_anchor_id_atoms_xreflabel_atoms
:END:
*** No Updates Within Transactions
<<atoms-no-update-within-transactions>>
:PROPERTIES:
:CUSTOM_ID: no_updates_within_transactions_anchor_id_atoms_no_update_within_transactions_xreflabel_atoms_no_update_within_transactions
:END:
Avoid atom updates inside STM transactions.

*** Prefer =swap!= over =reset!= <<atoms-prefer-swap-over-reset>>
:PROPERTIES:
:CUSTOM_ID: prefer_literal_swap_literal_over_literal_reset_literal_anchor_id_atoms_prefer_swap_over_reset_xreflabel_atoms_prefer_swap_over_reset
:END:
Try to use =swap!= rather than =reset!=, where possible.

#+begin_src clojure
(def a (atom 0))

;; good
(swap! a + 5)

;; not as good
(reset! a 5)
#+end_src

* Math
:PROPERTIES:
:CUSTOM_ID: math
:END:
** Prefer =clojure.math= Functions Over Interop
<<prefer-clojure-math-over-interop>>
:PROPERTIES:
:CUSTOM_ID: prefer_literal_clojure_math_literal_functions_over_interop_anchor_id_prefer_clojure_math_over_interop_xreflabel_prefer_clojure_math_over_interop
:END:
Prefer math functions from =clojure.math= over (Java) interop or rolling
your own.

#+begin_src clojure
;; good
(clojure.math/pow 2 5)

;; okish
(Math/pow 2 5)
#+end_src

The JDK package =java.lang.Math= provides access to many useful math
functions. Prior to version 1.11, Clojure relied on using these via
interop, but this had issues with discoverability, primitive
performance, higher order application, and portability. The new
=clojure.math= namespace provides wrapper functions for the methods
available in =java.lang.Math= for =long= and =double= overloads with
fast primitive invocation.

* Strings
:PROPERTIES:
:CUSTOM_ID: strings
:END:
** Prefer =clojure.string= Functions Over Interop
<<prefer-clojure-string-over-interop>>
:PROPERTIES:
:CUSTOM_ID: prefer_literal_clojure_string_literal_functions_over_interop_anchor_id_prefer_clojure_string_over_interop_xreflabel_prefer_clojure_string_over_interop
:END:
Prefer string manipulation functions from =clojure.string= over Java
interop or rolling your own.

#+begin_src clojure
;; good
(clojure.string/upper-case "bruce")

;; bad
(.toUpperCase "bruce")
#+end_src

Several new functions were added to =clojure.string= in Clojure 1.8
(=index-of=, =last-index-of=, =starts-with?=, =ends-with?= and
=includes?=). You should avoid using those if you need to support older
Clojure releases.

* Exceptions
:PROPERTIES:
:CUSTOM_ID: exceptions
:END:
** Reuse Existing Exception Types <<reuse-existing-exception-types>>
:PROPERTIES:
:CUSTOM_ID: reuse_existing_exception_types_anchor_id_reuse_existing_exception_types_xreflabel_reuse_existing_exception_types
:END:
Reuse existing exception types. Idiomatic Clojure code --- when it does
throw an exception --- throws an exception of a standard type (e.g.
=java.lang.IllegalArgumentException=,
=java.lang.UnsupportedOperationException=,
=java.lang.IllegalStateException=, =java.io.IOException=).

** Prefer =with-open= Over =finally= <<prefer-with-open-over-finally>>
:PROPERTIES:
:CUSTOM_ID: prefer_literal_with_open_literal_over_literal_finally_literal_anchor_id_prefer_with_open_over_finally_xreflabel_prefer_with_open_over_finally
:END:
Favor =with-open= over =finally=.

* Macros
:PROPERTIES:
:CUSTOM_ID: macros
:END:
** Don't Write a Macro If a Function Will Do
<<dont-write-macro-if-fn-will-do>>
:PROPERTIES:
:CUSTOM_ID: don_8217_t_write_a_macro_if_a_function_will_do_anchor_id_dont_write_macro_if_fn_will_do_xreflabel_dont_write_macro_if_fn_will_do
:END:
Don't write a macro if a function will do.

** Write Macro Usage before Writing the Macro
<<write-macro-usage-before-writing-the-macro>>
:PROPERTIES:
:CUSTOM_ID: write_macro_usage_before_writing_the_macro_anchor_id_write_macro_usage_before_writing_the_macro_xreflabel_write_macro_usage_before_writing_the_macro
:END:
Create an example of a macro usage first and the macro afterwards.

** Break Complicated Macros <<break-complicated-macros>>
:PROPERTIES:
:CUSTOM_ID: break_complicated_macros_anchor_id_break_complicated_macros_xreflabel_break_complicated_macros
:END:
Break complicated macros into smaller functions whenever possible.

** Macros as Syntactic Sugar <<macros-as-syntactic-sugar>>
:PROPERTIES:
:CUSTOM_ID: macros_as_syntactic_sugar_anchor_id_macros_as_syntactic_sugar_xreflabel_macros_as_syntactic_sugar
:END:
A macro should usually just provide syntactic sugar and the core of the
macro should be a plain function. Doing so will improve composability.

** Syntax Quoted Forms <<syntax-quoted-forms>>
:PROPERTIES:
:CUSTOM_ID: syntax_quoted_forms_anchor_id_syntax_quoted_forms_xreflabel_syntax_quoted_forms
:END:
Prefer syntax-quoted forms over building lists manually.

* Common Metadata
:PROPERTIES:
:CUSTOM_ID: common_metadata
:END:
In this section we'll go over some common metadata for namespaces and
vars that Clojure development tools can leverage.

** =:added=
:PROPERTIES:
:CUSTOM_ID: literal_added_literal
:END:
The most common way to document when a public API was added to a library
is via the =:added= metadata.

#+begin_src clojure
(def ^{:added "0.5"} foo
  42)

(ns foo.bar
  "A very useful ns."
  {:added "0.8"})

(defn ^{:added "0.5"} foo
  (bar))
#+end_src

If you're into SemVer, it's a good idea to omit the patch version. This
means you should use =0.5= instead of =0.5.0=. This applies for all
metadata data that's version related.

** =:changed=
:PROPERTIES:
:CUSTOM_ID: literal_changed_literal
:END:
The most common way to document when a public API was changed in a
library is via the =:changed= metadata. This metadata makes sense only
for vars and you should be using it sparingly, as changing the behavior
of a public API is generally a bad idea.

Still, if you decide to do it, it's best to make that clear to the API
users.

#+begin_src clojure
(def ^{:added "0.5"
       :changed "0.6"} foo
  43)
#+end_src

** =:deprecated=
:PROPERTIES:
:CUSTOM_ID: literal_deprecated_literal
:END:
The most common way to mark deprecated public APIs is via the
=:deprecated= metadata. Normally you'd use as the value the version in
which something was deprecated in case of versioned software (e.g. a
library) or simply =true= in the case of unversioned software (e.g. some
web application).

#+begin_src clojure
;;; good
;;
;; in case we have a version
(def ^{:deprecated "0.5"} foo
  "Use `bar` instead."
  42)

(ns foo.bar
  "A deprecated ns."
  {:deprecated "0.8"})

(defn ^{:deprecated "0.5"} foo
  (bar))

;; otherwise
(defn ^:deprecated foo
  (bar))

;;; bad
;;
;; using the docstring to signal deprecation
(def foo
  "DEPRECATED: Use `bar` instead."
  42)

(ns foo.bar
  "DEPRECATED: A deprecated ns.")
#+end_src

** =:superseded-by=
:PROPERTIES:
:CUSTOM_ID: literal_superseded_by_literal
:END:
Often you'd combine =:deprecated= with =:superseded-by=, as there would
be some newer API that supersedes whatever got deprecated.

Typically for vars you'll use a non-qualified name if the replacement
lives in the same namespace, and a fully-qualified name otherwise.

#+begin_src clojure
;; in case we have a version
(def ^{:deprecated "0.5"
       :superseded-by "bar"} foo
  "Use `bar` instead."
  42)

(ns foo.bar
  "A deprecated ns."
  {:deprecated "0.8"
   :superseded-by "foo.baz"})

(defn ^{:deprecated "0.5"
        :superseded-by "bar"} foo
  (bar))

;; otherwise
(defn ^{:deprecated true
        :superseded-by "bar"} foo
  (bar))
#+end_src

You can also consider adding =:supersedes= metadata to the newer APIs,
basically the inverse of =:superseded-by=.

** =:see-also=
:PROPERTIES:
:CUSTOM_ID: literal_see_also_literal
:END:
From time to time you might want to point out some related
vars/namespaces that the users of your library might be interested in.
The most common way to do so would be via the =:see-also= metadata,
which takes a vector of related items. When talking about vars - items
in the same namespace don't need to fully qualified.

#+begin_src clojure
;; refers to vars in the same ns
(def ^{:see-also ["bar" "baz"]} foo
  "A very useful var."
  42)

;; refers to vars in some other ns
(defn ^{:see-also ["top.bar" "top.baz"]} foo
  (bar))
#+end_src

Many Clojure programming tools will also try to extract references to
other vars from the docstring, but it's both simpler and more explicit
to use the =:see-also= metadata instead.

** =:no-doc=
:PROPERTIES:
:CUSTOM_ID: literal_no_doc_literal
:END:
Documentation tools like
[[https://github.com/weavejester/codox#metadata-options][Codox]] like
[[https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#hiding-namespaces-vars-in-documentation][cljdoc]]
recognize =:no-doc= metadata. When a var or a namespace has =:no-doc=
metadata, it indicates to these tools that it should be excluded from
generated API docs.

To exclude an entire namespace from API docs:

#+begin_src clojure
(ns ^:no-doc my-library.impl
  "Internal implementation details")

...
#+end_src

To exclude vars within a documented namespace:

#+begin_src clojure
(ns my-library.api)

;; private functions do not get documented
(defn- clearly-private []
  ...)

;; nor do public functions with :no-doc metadata
(defn ^:no-doc shared-helper []
  ...)

;; this function will be documented
(defn api-fn1
  "I am useful to the public"
  []
  ...)
#+end_src

** Indentation Metadata
:PROPERTIES:
:CUSTOM_ID: indentation_metadata
:END:
Unlike other Lisp dialects, Clojure doesn't have a standard metadata
format to specify the indentation of macros. CIDER proposed a
tool-agnostic
[[https://docs.cider.mx/cider/indent_spec.html][indentation
specification]] based on metadata in 2015.[fn:9] Here's a simple
example:

#+begin_src clojure
;; refers to vars in the same ns
(defmacro with-in-str
  "[DOCSTRING]"
  {:style/indent 1}
  [s & body]
  ...cut for brevity...)
#+end_src

This instructs the indentation engine that this is a macro with one
ordinary parameter and a body after it.

#+begin_src clojure
;; without metadata (indented as a regular function)
(dop-iin-str some-string
             foo
             bar
             baz)

;; with metadata (indented as macro with one special param and a body)
(with-in-str some-string
  foo
  bar
  baz)
#+end_src

Unfortunately, as of 2020 there's still no widespread adoption of
=:style/indent= and many editors and IDEs would just hardcode the
indentation rules for common macros.

This approach to indentation ("semantic indentation") is a contested
topic in the Clojure community, due to the need for the additional
metadata and tooling support. Despite the long tradition of that
approach in the Lisp community in general, some people argue to just
stop treating functions and macros differently and simply indent
everything with a fixed indentation.
[[https://tonsky.me/blog/clojurefmt/][This article]] is one popular
presentation of that alternative approach.

* Comments
:PROPERTIES:
:CUSTOM_ID: comments
:END:

#+begin_quote
Good code is its own best documentation. As you're about to add a
comment, ask yourself, "How can I improve the code so that this comment
isn't needed?" Improve the code and then document it to make it even
clearer.

---  Steve McConnell

#+end_quote

** Self-Explanatory Code
:PROPERTIES:
:CUSTOM_ID: self_explanatory_code
:END:
Endeavor to make your code as self-explanatory as possible. If you fail
to achieve this follow the rest of the guidelines in this section.

** Heading Comments <<four-semicolons-for-heading-comments>>
:PROPERTIES:
:CUSTOM_ID: heading_comments_anchor_id_four_semicolons_for_heading_comments_xreflabel_four_semicolons_for_heading_comments
:END:
Write heading comments with at least four semicolons. Those typically
serve to outline/separate major section of code, or to describe
important ideas. Often you'd have a section comment followed by a bunch
of top-level comments.

#+begin_src clojure
;;;; Section Comment/Heading

;;; Foo...
;;; Bar...
;;; Baz...
#+end_src

** Top-Level Comments <<three-semicolons-for-top-level-comments>>
:PROPERTIES:
:CUSTOM_ID: top_level_comments_anchor_id_three_semicolons_for_top_level_comments_xreflabel_three_semicolons_for_top_level_comments
:END:
Write top-level comments with three semicolons.

#+begin_src clojure
;;; I'm a top-level comment.
;;; I live outside any definition.

(defn foo [])
#+end_src

While the classic Lisp tradition dictates the use of =;;;= for top-level
comments, you'll find plenty of Clojure code in the wild that's using
=;;= or even =;=.

** Code Fragment (Line) Comments <<two-semicolons-for-code-fragment>>
:PROPERTIES:
:CUSTOM_ID: code_fragment_line_comments_anchor_id_two_semicolons_for_code_fragment_xreflabel_two_semicolons_for_code_fragment
:END:
Write comments on a particular fragment of code before that fragment and
aligned with it, using two semicolons.

#+begin_src clojure
(defn foo [x]
  ;; I'm a line/code fragment comment.
  x)
#+end_src

While the classic Lisp tradition dictates the use of =;;= for line
comments, you'll find plenty of Clojure code in the wild that's using
only =;=.

** Margin (Inline) Comments <<one-semicolon-for-margin-comments>>
:PROPERTIES:
:CUSTOM_ID: margin_inline_comments_anchor_id_one_semicolon_for_margin_comments_xreflabel_one_semicolon_for_margin_comments
:END:
Write margin comments with one semicolon.

#+begin_src clojure
(defn foo [x]
  x ; I'm a line/code fragment comment.
  )
#+end_src

Avoid using those in situations that would result in hanging closing
parentheses.

** Semicolon Space <<semicolon-space>>
:PROPERTIES:
:CUSTOM_ID: semicolon_space_anchor_id_semicolon_space_xreflabel_semicolon_space
:END:
Always have at least one space between the semicolon and the text that
follows it.

#+begin_src clojure
;;;; Frob Grovel

;;; This section of code has some important implications:
;;;   1. Foo.
;;;   2. Bar.
;;;   3. Baz.

(defn fnord [zarquon]
  ;; If zob, then veeblefitz.
  (quux zot
        mumble             ; Zibblefrotz.
        frotz))
#+end_src

** English Syntax <<english-syntax>>
:PROPERTIES:
:CUSTOM_ID: english_syntax_anchor_id_english_syntax_xreflabel_english_syntax
:END:
Comments longer than a word begin with a capital letter and use
punctuation. Separate sentences with
[[https://en.wikipedia.org/wiki/Sentence_spacing][one space]].

#+begin_src clojure
;; This is a good comment.

;; this is a bad comment
#+end_src

Obviously punctuation is not the most important thing about a comment,
but a bit of extra effort results in better experience for the readers
of our comments.

** No Superfluous Comments <<no-superfluous-comments>>
:PROPERTIES:
:CUSTOM_ID: no_superfluous_comments_anchor_id_no_superfluous_comments_xreflabel_no_superfluous_comments
:END:
Avoid superfluous comments.

#+begin_src clojure
;; bad
(inc counter) ; increments counter by one
#+end_src

** Comment Upkeep <<comment-upkeep>>
:PROPERTIES:
:CUSTOM_ID: comment_upkeep_anchor_id_comment_upkeep_xreflabel_comment_upkeep
:END:
Keep existing comments up-to-date. An outdated comment is worse than no
comment at all.

** =#_= Reader Macro <<dash-underscore-reader-macro>>
:PROPERTIES:
:CUSTOM_ID: literal___literal_reader_macro_anchor_id_dash_underscore_reader_macro_xreflabel_dash_underscore_reader_macro
:END:
Prefer the use of the =#_= reader macro over a regular comment when you
need to comment out a particular form.

#+begin_src clojure
;; good
(+ foo #_(bar x) delta)

;; bad
(+ foo
   ;; (bar x)
   delta)
#+end_src

** Refactor, Don't Comment <<refactor-dont-comment>>
:PROPERTIES:
:CUSTOM_ID: refactor_don_8217_t_comment_anchor_id_refactor_dont_comment_xreflabel_refactor_dont_comment
:END:

#+begin_quote
Good code is like a good joke - it needs no explanation.

---  Russ Olsen

#+end_quote

Avoid writing comments to explain bad code. Refactor the code to make it
self-explanatory. ("Do, or do not. There is no try." --Yoda)

** Comment Annotations
:PROPERTIES:
:CUSTOM_ID: comment_annotations
:END:
*** Annotate Above <<annotate-above>>
:PROPERTIES:
:CUSTOM_ID: annotate_above_anchor_id_annotate_above_xreflabel_annotate_above
:END:
Annotations should usually be written on the line immediately above the
relevant code.

#+begin_src clojure
;; good
(defn some-fun
  []
  ;; FIXME: Replace baz with the newer bar.
  (baz))

;; bad
;; FIXME: Replace baz with the newer bar.
(defn some-fun
  []
  (baz))
#+end_src

*** Annotate Keywords <<annotate-keywords>>
:PROPERTIES:
:CUSTOM_ID: annotate_keywords_anchor_id_annotate_keywords_xreflabel_annotate_keywords
:END:
The annotation keyword is followed by a colon and a space, then a note
describing the problem.

#+begin_src clojure
;; good
(defn some-fun
  []
  ;; FIXME: Replace baz with the newer bar.
  (baz))

;; bad - no colon after annotation
(defn some-fun
  []
  ;; FIXME Replace baz with the newer bar.
  (baz))

;; bad - no space after colon
(defn some-fun
  []
  ;; FIXME:Replace baz with the newer bar.
  (baz))
#+end_src

*** Indent Annotations <<indent-annotations>>
:PROPERTIES:
:CUSTOM_ID: indent_annotations_anchor_id_indent_annotations_xreflabel_indent_annotations
:END:
If multiple lines are required to describe the problem, subsequent lines
should be indented as much as the first one.

#+begin_src clojure
;; good
(defn some-fun
  []
  ;; FIXME: This has crashed occasionally since v1.2.3. It may
  ;;        be related to the BarBazUtil upgrade. (xz 13-1-31)
  (baz))

;; bad
(defn some-fun
  []
  ;; FIXME: This has crashed occasionally since v1.2.3. It may
  ;; be related to the BarBazUtil upgrade. (xz 13-1-31)
  (baz))
#+end_src

*** Sign and Date Annotations <<sign-and-date-annotations>>
:PROPERTIES:
:CUSTOM_ID: sign_and_date_annotations_anchor_id_sign_and_date_annotations_xreflabel_sign_and_date_annotations
:END:
Tag the annotation with your initials and a date so its relevance can be
easily verified.

#+begin_src clojure
(defn some-fun
  []
  ;; FIXME: This has crashed occasionally since v1.2.3. It may
  ;;        be related to the BarBazUtil upgrade. (xz 13-1-31)
  (baz))
#+end_src

*** Rare Margin (EOL) Annotations <<rare-eol-annotations>>
:PROPERTIES:
:CUSTOM_ID: rare_margin_eol_annotations_anchor_id_rare_eol_annotations_xreflabel_rare_eol_annotations
:END:
In cases where the problem is so obvious that any documentation would be
redundant, annotations may be left at the end of the offending line with
no note. This usage should be the exception and not the rule.

#+begin_src clojure
(defn bar
  []
  (sleep 100)) ; OPTIMIZE
#+end_src

*** =TODO= <<todo>>
:PROPERTIES:
:CUSTOM_ID: literal_todo_literal_anchor_id_todo_xreflabel_todo
:END:
Use =TODO= to note missing features or functionality that should be
added at a later date.

*** =FIXME= <<fixme>>
:PROPERTIES:
:CUSTOM_ID: literal_fixme_literal_anchor_id_fixme_xreflabel_fixme
:END:
Use =FIXME= to note broken code that needs to be fixed.

*** =OPTIMIZE= <<optimize>>
:PROPERTIES:
:CUSTOM_ID: literal_optimize_literal_anchor_id_optimize_xreflabel_optimize
:END:
Use =OPTIMIZE= to note slow or inefficient code that may cause
performance problems.

*** =HACK= <<hack>>
:PROPERTIES:
:CUSTOM_ID: literal_hack_literal_anchor_id_hack_xreflabel_hack
:END:
Use =HACK= to note "code smells" where questionable coding practices
were used and should be refactored away.

*** =REVIEW= <<review>>
:PROPERTIES:
:CUSTOM_ID: literal_review_literal_anchor_id_review_xreflabel_review
:END:
Use =REVIEW= to note anything that should be looked at to confirm it is
working as intended. For example:
=REVIEW: Are we sure this is how the client does X currently?=

*** Document Custom Annotations <<document-annotations>>
:PROPERTIES:
:CUSTOM_ID: document_custom_annotations_anchor_id_document_annotations_xreflabel_document_annotations
:END:
Use other custom annotation keywords if it feels appropriate, but be
sure to document them in your project's =README= or similar.

* Documentation
:PROPERTIES:
:CUSTOM_ID: documentation
:END:
Docstrings are the primary way to document Clojure code. Many definition
forms (e.g. =def=, =defn=, =defmacro=, =ns=) support docstrings and
usually it's a good idea to make good use of them, regardless of whether
the var in question is something public or private.

If a definition form doesn't support docstrings directly you can still
supply them via the =:doc= metadata attribute.

This section outlines some of the common conventions and best practices
for documenting Clojure code.

** Prefer Docstrings <<prefer-docstrings>>
:PROPERTIES:
:CUSTOM_ID: prefer_docstrings_anchor_id_prefer_docstrings_xreflabel_prefer_docstrings
:END:
If a form supports docstrings directly prefer them over using =:doc=
metadata:

#+begin_src clojure
;; good
(defn foo
  "This function doesn't do much."
  []
  ...)

(ns foo.bar.core
  "That's an awesome library.")

;; bad
(defn foo
  ^{:doc "This function doesn't do much."}
  []
  ...)

(ns ^{:doc "That's an awesome library.")
  foo.bar.core)
#+end_src

** Docstring Summary <<docstring-summary>>
:PROPERTIES:
:CUSTOM_ID: docstring_summary_anchor_id_docstring_summary_xreflabel_docstring_summary
:END:
Let the first line in the docstring be a complete, capitalized sentence
which concisely describes the var in question. This makes it easy for
tooling (Clojure editors and IDEs) to display a short a summary of the
docstring at various places.

#+begin_src clojure
;; good
(defn frobnitz
  "This function does a frobnitz.
  It will do gnorwatz to achieve this, but only under certain
  circumstances."
  []
  ...)

;; bad
(defn frobnitz
  "This function does a frobnitz. It will do gnorwatz to
  achieve this, but only under certain circumstances."
  []
  ...)
#+end_src

** Leverage Markdown in Docstrings <<markdown-docstrings>>
:PROPERTIES:
:CUSTOM_ID: leverage_markdown_in_docstrings_anchor_id_markdown_docstrings_xreflabel_markdown_docstrings
:END:
Important tools such as
[[https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#docstrings][cljdoc]]
support Markdown in docstrings so leverage it for nicely formatted
documentation.

#+begin_src clojure
;; good
(defn qzuf-number
  "Computes the [Qzuf number](https://wikipedia.org/qzuf) of the `coll`.
  Supported options in `opts`:

  | key           | description |
  | --------------|-------------|
  | `:finite-uni?`| Assume finite universe; default: `false`
  | `:complex?`   | If OK to return a [complex number](https://en.wikipedia.org/wiki/Complex_number); default: `false`
  | `:timeout`    | Throw an exception if the computation doesn't finish within `:timeout` milliseconds; default: `nil`

  Example:
  ```clojure
  (when (neg? (qzuf-number [1 2 3] {:finite-uni? true}))
    (throw (RuntimeException. \"Error in the Universe!\")))
  ```"
  [coll opts]
  ...)
#+end_src

** Document Positional Arguments <<document-pos-arguments>>
:PROPERTIES:
:CUSTOM_ID: document_positional_arguments_anchor_id_document_pos_arguments_xreflabel_document_pos_arguments
:END:
Document all positional arguments, and wrap them them with backticks (`)
so that editors and IDEs can identify them and potentially provide extra
functionality for them.

#+begin_src clojure
;; good
(defn watsitz
  "Watsitz takes a `frob` and converts it to a znoot.
  When the `frob` is negative, the znoot becomes angry."
  [frob]
  ...)

;; bad
(defn watsitz
  "Watsitz takes a frob and converts it to a znoot.
  When the frob is negative, the znoot becomes angry."
  [frob]
  ...)
#+end_src

** Document References <<document-references>>
:PROPERTIES:
:CUSTOM_ID: document_references_anchor_id_document_references_xreflabel_document_references
:END:
Wrap any var references in the docstring with ` so that tooling can
identify them. Wrap them with =[[..]]= if you want to link to them.

#+begin_src clojure
;; good
(defn wombat
  "Acts much like `clojure.core/identity` except when it doesn't.
  Takes `x` as an argument and returns that. If it feels like it.
  See also [[kangaroo]]."
  [x]
  ...)

;; bad
(defn wombat
  "Acts much like clojure.core/identity except when it doesn't.
  Takes `x` as an argument and returns that. If it feels like it.
  See also kangaroo."
  [x]
  ...)
#+end_src

** Docstring Grammar <<docstring-grammar>>
:PROPERTIES:
:CUSTOM_ID: docstring_grammar_anchor_id_docstring_grammar_xreflabel_docstring_grammar
:END:
Docstrings should be composed of well-formed English sentences. Every
sentence should start with a capitalized word, be grammatically
coherent, and end with appropriate punctuation. Sentences should be
separated with a single space.

#+begin_src clojure
;; good
(def foo
  "All sentences should end with a period (or maybe an exclamation mark).
  The sentence should be followed by a space, unless it concludes the docstring.")

;; bad
(def foo
  "all sentences should end with a period (or maybe an exclamation mark).
  The sentence should be followed by a space, unless it concludes the docstring.")
#+end_src

** Docstring Indentation <<docstring-indentation>>
:PROPERTIES:
:CUSTOM_ID: docstring_indentation_anchor_id_docstring_indentation_xreflabel_docstring_indentation
:END:
Indent multi-line docstrings by two spaces.

#+begin_src clojure
;; good
(ns my.ns
  "It is actually possible to document a ns.
  It's a nice place to describe the purpose of the namespace and maybe even
  the overall conventions used. Note how _not_ indenting the docstring makes
  it easier for tooling to display it correctly.")

;; bad
(ns my.ns
  "It is actually possible to document a ns.
It's a nice place to describe the purpose of the namespace and maybe even
the overall conventions used. Note how _not_ indenting the docstring makes
it easier for tooling to display it correctly.")
#+end_src

** Docstring Leading Trailing Whitespace
<<docstring-leading-trailing-whitespace>>
:PROPERTIES:
:CUSTOM_ID: docstring_leading_trailing_whitespace_anchor_id_docstring_leading_trailing_whitespace_xreflabel_docstring_leading_trailing_whitespace
:END:
Neither start nor end your docstrings with any whitespace.

#+begin_src clojure
;; good
(def foo
  "I'm so awesome."
  42)

;; bad
(def silly
  "    It's just silly to start a docstring with spaces.
  Just as silly as it is to end it with a bunch of them.      "
  42)
#+end_src

** Place Docstring After Function Name <<docstring-after-fn-name>>
:PROPERTIES:
:CUSTOM_ID: place_docstring_after_function_name_anchor_id_docstring_after_fn_name_xreflabel_docstring_after_fn_name
:END:
When adding a docstring --- especially to a function using the above
form --- take care to correctly place the docstring after the function
name, not after the argument vector. The latter is not invalid syntax
and won't cause an error, but includes the string as a form in the
function body without attaching it to the var as documentation.

#+begin_src clojure
;; good
(defn foo
  "docstring"
  [x]
  (bar x))

;; bad
(defn foo [x]
  "docstring"
  (bar x))
#+end_src

Place docstrings for =defprotocol= methods /after/ the argument vector:

#+begin_src clojure
(defprotocol MyProtocol
  "MyProtocol docstring"
  (foo [this x y z]
    "foo docstring")
  (bar [this]
    "bar docstring"))
#+end_src

* Testing
:PROPERTIES:
:CUSTOM_ID: testing
:END:
** Test Directory Structure <<test-directory-structure>>
:PROPERTIES:
:CUSTOM_ID: test_directory_structure_anchor_id_test_directory_structure_xreflabel_test_directory_structure
:END:
Store your tests in a separate directory, typically =test/yourproject/=
(as opposed to =src/yourproject/=). Your build tool is responsible for
making them available in the contexts where they are necessary; most
templates will do this for you automatically.

** Test Namespace Naming <<test-ns-naming>>
:PROPERTIES:
:CUSTOM_ID: test_namespace_naming_anchor_id_test_ns_naming_xreflabel_test_ns_naming
:END:
Name your ns =yourproject.something-test=, a file which usually lives in
=test/yourproject/something_test.clj= (or =.cljc=, =cljs=).

** Test Naming <<test-naming>>
:PROPERTIES:
:CUSTOM_ID: test_naming_anchor_id_test_naming_xreflabel_test_naming
:END:
When using =clojure.test=, define your tests with =deftest= and name
them =something-test=.

#+begin_src clojure
;; good
(deftest something-test ...)

;; bad
(deftest something-tests ...)
(deftest test-something ...)
(deftest something ...)
#+end_src

* Library Organization
:PROPERTIES:
:CUSTOM_ID: library_organization
:END:
** Library Coordinates <<lib-coordinates>>
:PROPERTIES:
:CUSTOM_ID: library_coordinates_anchor_id_lib_coordinates_xreflabel_lib_coordinates
:END:
If you are publishing libraries to be used by others, make sure to
follow the
[[https://central.sonatype.org/pages/choosing-your-coordinates.html][Central
Repository guidelines]] for choosing your =groupId= and =artifactId=.
This helps to prevent name conflicts and facilitates the widest possible
use. A good example is
[[https://github.com/stuartsierra/component][Component]] - its
coordinates are =com.stuartsierra/component=.

Another approach that's popular in the wild is to use a project (or
organization) name as the =groupId= instead of domain name. Examples of
such naming would be:

- =cider/cider-nrepl=

- =nrepl/nrepl=

- =nrepl/drawbridge=

- =clj-commons/fs=

** Minimize Dependencies <<lib-min-dependencies>>
:PROPERTIES:
:CUSTOM_ID: minimize_dependencies_anchor_id_lib_min_dependencies_xreflabel_lib_min_dependencies
:END:
Avoid unnecessary dependencies. For example, a three-line utility
function copied into a project is usually better than a dependency that
drags in hundreds of vars you do not plan to use.

** Tool-agnostic <<lib-core-separate-from-tools>>
:PROPERTIES:
:CUSTOM_ID: tool_agnostic_anchor_id_lib_core_separate_from_tools_xreflabel_lib_core_separate_from_tools
:END:
Deliver core functionality and integration points in separate artifacts.
That way, consumers can consume your library without being constrained
by your unrelated tooling preferences. For example,
[[https://github.com/stuartsierra/component][Component]] provides core
functionality, and
[[https://github.com/stuartsierra/reloaded][reloaded]] provides
leiningen integration.

* Existential
:PROPERTIES:
:CUSTOM_ID: existential
:END:
** Be Functional <<be-functional>>
:PROPERTIES:
:CUSTOM_ID: be_functional_anchor_id_be_functional_xreflabel_be_functional
:END:
Code in a functional way, using mutation only when it makes sense.

** Be Consistent <<be-consistent>>
:PROPERTIES:
:CUSTOM_ID: be_consistent_anchor_id_be_consistent_xreflabel_be_consistent
:END:
Be consistent. In an ideal world, be consistent with these guidelines.

** Common Sense <<common-sense>>
:PROPERTIES:
:CUSTOM_ID: common_sense_anchor_id_common_sense_xreflabel_common_sense
:END:
Use common sense.

* Tools
:PROPERTIES:
:CUSTOM_ID: tools
:END:
One problem with style guides is that it's often hard to remember all
the guidelines and to apply them consistently. We're only humans, after
all. Fortunately, there are a bunch of tools that can do most of the
work for us.

It's a great idea run such tools as part of your continuous integration
(CI). This ensure that all the code in one project is consistent with
the style you're aiming for.

** Lint Tools
:PROPERTIES:
:CUSTOM_ID: lint_tools
:END:
There are some lint tools created by the Clojure community that might
aid you in your endeavor to write idiomatic Clojure code.

- [[https://github.com/jonase/kibit][kibit]] is a static code analyzer
  for Clojure which uses
  [[https://github.com/clojure/core.logic][core.logic]] to search for
  patterns of code for which there might exist a more idiomatic function
  or macro.

- [[https://github.com/borkdude/clj-kondo][clj-kondo]] is a linter that
  detects a wide number of discouraged patterns and suggests
  improvements, based on this style guide.

** Code Formatters
:PROPERTIES:
:CUSTOM_ID: code_formatters
:END:
While most Clojure editors and IDEs can format the code, according to
the layout guidelines outlined here, it's always handy to have some
command-line code formatting tools. There are a couple of options for
Clojure that do a great job when it comes to formatting the code as
suggested in this guide:

- [[https://github.com/weavejester/cljfmt][cljfmt]]

- [[https://github.com/greglook/cljstyle][cljstyle]]

- [[https://github.com/kkinnear/zprint][zprint]] (the documentation for
  configuring it to use the community formatting rules is
  [[https://github.com/kkinnear/zprint/blob/master/doc/options/community.md][here]])

When it comes to editors - Emacs's =clojure-mode= by default will format
the code exactly as outlined in the guide. Other editors might require
some configuration tweaking to produce the same results.

* History
:PROPERTIES:
:CUSTOM_ID: history
:END:
This guide was started in 2013 by [[https://github.com/bbatsov][Bozhidar
Batsov]], following the success of a [[https://rubystyle.guide/][similar
project]] he had created in the Ruby community.

Bozhidar was very passionate about both Clojure and good programming
style and he wanted to bridge the gap between what was covered by the
[[https://clojure.org/community/contrib_howto#_coding_guidelines][Clojure
library coding guidelines]] and what the style guides for languages like
Java, Python and Ruby would typically cover. Bozhidar still serves as
the guide's primary editor, but there's an entire editor team supporting
the project.

Since the inception of the guide we've received a lot of feedback from
members of the exceptional Clojure community around the world. Thanks
for all the suggestions and the support! Together we can make a resource
beneficial to each and every Clojure developer out there.

* Sources of Inspiration
:PROPERTIES:
:CUSTOM_ID: sources_of_inspiration
:END:
Many people, books, presentations, articles and other style guides
influenced the community Clojure style guide. Here are some of them:

- [[https://en.wikipedia.org/wiki/The_Elements_of_Style]["The Elements
  of Style"]]

- [[https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style]["The
  Elements of Programming Style"]]

- [[https://www.python.org/dev/peps/pep-0008/][Python Style Guide
  (PEP-8)]]

- [[https://rubystyle.guide/][Community Ruby Style Guide]]

- [[https://google.github.io/styleguide/lispguide.xml][Google's Common
  Lisp Style Guide]]

- [[http://community.schemewiki.org/?scheme-style][scheme-style]]

- [[https://clojure.org/community/contrib_howto#_coding_guidelines][Clojure
  Library Coding Guidelines]]

- [[https://www.clojurebook.com/]["Clojure Programming"]]

- [[https://joyofclojure.com/]["The Joy of Clojure"]]

- [[https://elementsofclojure.com/]["Elements of Clojure"]]

- [[https://pragprog.com/titles/vmclojeco/clojure-applied/]["Clojure
  Applied"]]

- [[https://stuartsierra.com/tag/dos-and-donts][Stuart Sierra's "Clojure
  Dos and Don't" blog series]]

* Editor Team
:PROPERTIES:
:CUSTOM_ID: editor_team
:END:
The Clojure style guide is stewarded by an editor team of experienced
Clojurists that aims to reduce all the input we get (e.g. feedback and
suggestions) to a better reference for everyone.

- [[https://metaredux.com/about/][Bozhidar Batsov]]

- [[https://insideclojure.org/about/][Alex Miller]]

- [[https://danielcompton.net/about][Daniel Compton]]

- [[https://corfield.org/][Sean Corfield]]

* Contributing
:PROPERTIES:
:CUSTOM_ID: contributing
:END:
The guide is still a work in progress - some guidelines are lacking
examples, some guidelines don't have examples that illustrate them
clearly enough. Improving such guidelines is a great (and simple way) to
help the Clojure community!

In due time these issues will (hopefully) be addressed - just keep them
in mind for now.

Nothing written in this guide is set in stone. It's my desire to work
together with everyone interested in Clojure coding style, so that we
could ultimately create a resource that will be beneficial to the entire
Clojure community.

Feel free to open tickets or send pull requests with improvements.
Thanks in advance for your help!

You can also support the style guide (and all my Clojure projects like
CIDER, nREPL, orchard, etc) with financial contributions via one of the
following platforms:

- [[https://github.com/sponsors/bbatsov][GitHub Sponsors]]

- [[https://ko-fi.com/bbatsov][ko-fi]]

- [[https://www.patreon.com/bbatsov][Patreon]]

- [[https://www.paypal.me/bbatsov][PayPal]]

** How to Contribute?
:PROPERTIES:
:CUSTOM_ID: how_to_contribute
:END:
It's easy, just follow the contribution guidelines below:

- [[https://help.github.com/articles/fork-a-repo][Fork]]
  [[https://github.com/bbatsov/clojure-style-guide][bbatsov/clojure-style-guide]]
  on GitHub

- Make your feature addition or bug fix in a feature branch.

- Include a
  [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][good
  description]] of your changes

- Push your feature branch to GitHub

- Send a [[https://help.github.com/articles/using-pull-requests][Pull
  Request]]

* Colophon
:PROPERTIES:
:CUSTOM_ID: colophon
:END:
This guide is written in [[https://asciidoc.org/][AsciiDoc]] and is
published as HTML using [[https://asciidoctor.org/][AsciiDoctor]]. The
HTML version of the guide is hosted on GitHub Pages.

Originally the guide was written in Markdown, but was converted to
AsciiDoc in 2019.

* License
:PROPERTIES:
:CUSTOM_ID: license
:END:
[[https://i.creativecommons.org/l/by/3.0/88x31.png]] This work is
licensed under a
[[https://creativecommons.org/licenses/by/3.0/deed.en_US][Creative
Commons Attribution 3.0 Unported License]]

* Spread the Word
:PROPERTIES:
:CUSTOM_ID: spread_the_word
:END:
A community-driven style guide is of little use to a community that
doesn't know about its existence. Tweet about the guide, share it with
your friends and colleagues. Every comment, suggestion or opinion we get
makes the guide just a little bit better. And we want to have the best
possible guide, don't we?

[fn:1] Those guidelines are meant to be applied to Clojure itself and to
       all the Clojure Contrib libraries.

[fn:2] Occasionally we might suggest to the reader to consider some
       alternatives, though.

[fn:3] You'll notice that the Clojure style guide is pretty similar in
       structure to the Ruby style guide, which served as its main
       source of inspiration. You'll also notice that the Ruby style
       guide is much longer, mostly because of the complexity of the
       Ruby language.

[fn:4] This section is heavily inspired by Python's PEP-8

[fn:5] *BSD/Solaris/Linux/macOS users are covered by default, Windows
       users have to be extra careful.

[fn:6] These guidelines are based on a
       [[https://stuartsierra.com/2015/05/10/clojure-namespace-aliases][blog
       post]] by Stuart Sierra.

[fn:7] Technically this will shadow the =ns= macro, but it's extremely
       unlikely you'll ever need it in the body of a function.

[fn:8] You can read more on the subject
       [[https://ask.clojure.org/index.php/8373/when-should-prefer-comp-and-partial-to-anonymous-functions][here]].

[fn:9] This was first introduced in CIDER 0.10
