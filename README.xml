<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>The Clojure Style Guide</title>
</articleinfo>
<section id="introduction">
<title>Introduction</title>
<blockquote>
<attribution>
Officer Alex J. Murphy / RoboCop
</attribution>
<simpara>Role models are important.</simpara>
</blockquote>
<simpara>This Clojure style guide recommends best practices so that real-world Clojure
programmers can write code that can be maintained by other real-world Clojure
programmers. A style guide that reflects real-world usage gets used, and a
style guide that holds to an ideal that has been rejected by the people it is
supposed to help risks not getting used at all&#8201;&#8212;&#8201;no matter how good it is.</simpara>
<simpara>The guide is separated into several sections of related rules. we&#8217;ve
tried to add the rationale behind the rules (if it&#8217;s omitted, we&#8217;ve
assumed that it&#8217;s pretty obvious).</simpara>
<simpara>We didn&#8217;t come up with all the rules out of nowhere; they are mostly
based on the experience of the style guide&#8217;s editors,
feedback and suggestions from numerous members of the Clojure community, and
various highly regarded Clojure programming resources, such as
<ulink url="https://www.clojurebook.com/">"Clojure Programming"</ulink>
and <ulink url="http://www.joyofclojure.com/">"The Joy of Clojure"</ulink>.</simpara>
<simpara>Nothing written here is set in stone.
This style guide evolves over time as additional conventions are
identified and past conventions are rendered obsolete by changes in
Clojure itself.</simpara>
<note><simpara>Clojure&#8217;s developers also maintain a list of
<ulink url="https://clojure.org/community/contrib_howto#_coding_guidelines">coding
guidelines for libraries</ulink>.<footnote><simpara>Those guidelines are meant to
be applied to Clojure itself and to all the Clojure Contrib libraries.</simpara></footnote>
They were one of the sources of inspiration for the document, you&#8217;re
currently reading.</simpara></note>
<section id="guiding_principles">
<title>Guiding Principles</title>
<blockquote>
<attribution>
Harold Abelson
<citetitle>Structure and Interpretation of Computer Programs</citetitle>
</attribution>
<simpara>Programs must be written for people to read, and only incidentally for machines to execute.</simpara>
</blockquote>
<simpara>It&#8217;s common knowledge that code is read much more often than it is written.
The guidelines provided here are intended to improve the readability of code and make it consistent across the wide spectrum of Clojure code.
They are also meant to reflect real-world usage of Clojure instead of a random ideal. When we had to choose between a very established practice
and a subjectively better alternative we&#8217;ve opted to recommend the established practice.<footnote><simpara>Occasionally we might suggest to the reader to consider some alternatives, though.</simpara></footnote></simpara>
<simpara>There are some areas in which there is no clear consensus in the Clojure community regarding a particular style (like semantic indentation vs fixed indentation, semantic comments vs uniform comments, etc).
In such scenarios all popular styles are acknowledged and it&#8217;s up to you to pick one and apply it consistently.</simpara>
<simpara>Fortunately Clojure is a Lisp, and Lisps are fundamentally
simple. Even though this guide was created a few years after Clojure
(the first version was published in early 2013), you could see that most
Clojure code in the wild was fairly uniform. We attribute this to
both the simplicity we already mentioned and to the fact that since day
1 Clojurists adopted many of the style conventions of other
established Lisp dialects (e.g. Common Lisp and Scheme).  This made
the work on this guide fairly easy and straight-forward, especially compared to
the massive exercise in frustration that was the
<ulink url="https://rubystyle.guide">Community Ruby Style Guide</ulink>.<footnote><simpara>You&#8217;ll notice that the Clojure style guide is pretty similar in structure to the Ruby style guide, which served as its main source of inspiration. You&#8217;ll also notice that the Ruby style guide is much longer, mostly because of the complexity of the Ruby language.</simpara></footnote></simpara>
<simpara>Clojure is famously optimized for simplicity and clarity. We&#8217;d like to believe that this guide is going to help you optimize for maximum
simplicity and clarity.</simpara>
</section>
<section id="a_note_about_consistency">
<title>A Note About Consistency</title>
<blockquote>
<attribution>
Ralph Waldo Emerson
</attribution>
<simpara>A foolish consistency is the hobgoblin of little minds, adored by little statesmen and philosophers and divines.</simpara>
</blockquote>
<simpara>A style guide is about consistency.<footnote><simpara>This section is heavily inspired by Python&#8217;s PEP-8</simpara></footnote>
Consistency with this style guide is important.
Consistency within a project is more important.
Consistency within one class or method is the most important.</simpara>
<simpara>However, know when to be inconsistent&#8201;&#8212;&#8201;sometimes style guide recommendations just aren&#8217;t applicable. When in doubt, use your best judgment.
Look at other examples and decide what looks best. And don&#8217;t hesitate to ask!</simpara>
<simpara>In particular: do not break backwards compatibility just to comply with this guide!</simpara>
<simpara>Some other good reasons to ignore a particular guideline:</simpara>
<itemizedlist>
<listitem>
<simpara>
When applying the guideline would make the code less readable, even for someone who is used to reading code that follows this style guide.
</simpara>
</listitem>
<listitem>
<simpara>
To be consistent with surrounding code that also breaks it (maybe for historic reasons)&#8201;&#8212;&#8201;although this is also an opportunity to clean up someone else&#8217;s mess (in true XP style).
</simpara>
</listitem>
<listitem>
<simpara>
Because the code in question predates the introduction of the guideline and there is no other reason to be modifying that code.
</simpara>
</listitem>
<listitem>
<simpara>
When the code needs to remain compatible with older versions of Clojure that don&#8217;t support the feature recommended by the style guide.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="translations">
<title>Translations</title>
<simpara>Translations of the guide are available in the following languages:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/geekerzp/clojure-style-guide/blob/master/README-zhCN.md">Chinese</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/totakke/clojure-style-guide/blob/ja/README.adoc">Japanese</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/kwakbab/clojure-style-guide/blob/master/README-koKO.md">Korean</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/theSkilled/clojure-style-guide/blob/pt-BR/README.md">Portuguese</ulink> (Under progress)
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/Nondv/clojure-style-guide/blob/master/ru/README.md">Russian</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/jeko2000/clojure-style-guide/blob/master/README.md">Spanish</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/LeaveNhA/clojure-style-guide/blob/master/README.adoc">Turkish</ulink>
</simpara>
</listitem>
</itemizedlist>
<note><simpara>These translations are not maintained by our editor team, so their quality
and level of completeness may vary. The translated versions of the guide often
lag behind the upstream English version.</simpara></note>
</section>
</section>
<section id="source_code_layout_amp_organization">
<title>Source Code Layout &amp; Organization</title>
<blockquote>
<attribution>
Jerry Coffin (on indentation)
</attribution>
<simpara>Nearly everybody is convinced that every style but their own is
ugly and unreadable. Leave out the "but their own" and they&#8217;re
probably right&#8230;</simpara>
</blockquote>
<simpara>Where feasible, avoid making lines longer than 80 characters.</simpara>
<sidebar>
<title>Why Bother with 80 characters in a World of Modern Widescreen Displays?</title>
<simpara>A lot of people these days feel that a maximum line length of 80 characters is
just a remnant of the past and makes little sense today. After all - modern
displays can easily fit 200+ characters on a single line.  Still, there are some
important benefits to be gained from sticking to shorter lines of code.</simpara>
<simpara>First, and foremost - numerous studies have shown that humans read much faster
vertically and very long lines of text impede the reading process. As noted
earlier, one of the guiding principles of this style guide is to optimize the
code we write for human consumption.</simpara>
<simpara>Additionally, limiting the required editor window width makes it possible to
have several files open side-by-side, and works well when using code review
tools that present the two versions in adjacent columns.</simpara>
<simpara>The default wrapping in most tools disrupts the visual structure of the code,
making it more difficult to understand. The limits are chosen to avoid wrapping
in editors with the window width set to 80, even if the tool places a marker
glyph in the final column when wrapping lines. Some web based tools may not
offer dynamic line wrapping at all.</simpara>
<simpara>Some teams strongly prefer a longer line length. For code maintained exclusively
or primarily by a team that can reach agreement on this issue, it is okay to
increase the line length limit up to 100 characters, or all the way up
to 120 characters. Please, restrain the urge to go beyond 120 characters.</simpara>
</sidebar>
<section id="tabs_vs_spaces_anchor_id_spaces_xreflabel_spaces">
<title>Tabs vs Spaces <anchor id="spaces" xreflabel="[spaces]"/></title>
<simpara>Use <emphasis role="strong">spaces</emphasis> for indentation. No hard tabs.</simpara>
</section>
<section id="body_indentation_anchor_id_body_indentation_xreflabel_body_indentation">
<title>Body Indentation <anchor id="body-indentation" xreflabel="[body-indentation]"/></title>
<simpara>Use 2 spaces to indent the bodies of
forms that have body parameters.  This covers all <literal>def</literal> forms, special
forms and macros that introduce local bindings (e.g. <literal>loop</literal>, <literal>let</literal>,
<literal>when-let</literal>) and many macros like <literal>when</literal>, <literal>cond</literal>, <literal>+as-&gt;+</literal>, <literal>+cond-&gt;+</literal>, <literal>case</literal>,
<literal>with-*</literal>, etc.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(when something
  (something-else))

(with-out-str
  (println "Hello, ")
  (println "world!"))

;; bad - four spaces
(when something
    (something-else))

;; bad - one space
(with-out-str
 (println "Hello, ")
 (println "world!"))</programlisting>
</section>
<section id="function_arguments_alignment_anchor_id_vertically_align_fn_args_xreflabel_vertically_align_fn_args">
<title>Function Arguments Alignment <anchor id="vertically-align-fn-args" xreflabel="[vertically-align-fn-args]"/></title>
<simpara>Vertically align function (macro) arguments spanning multiple lines.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(filter even?
        (range 1 10))

;; bad - argument aligned with function name (one space indent)
(filter even?
 (range 1 10))

;; bad - two space indent
(filter even?
  (range 1 10))</programlisting>
<simpara>The reasoning behind this guideline is pretty simple - the arguments are
easier to process by the human brain if they stand out and stick together.</simpara>
</section>
<section id="function_arguments_indentation_anchor_id_one_space_indent_xreflabel_one_space_indent">
<title>Function Arguments Indentation <anchor id="one-space-indent" xreflabel="[one-space-indent]"/></title>
<note><simpara>Generally, you should stick to the formatting outlined in the previous
guideline, unless you&#8217;re limited by the available horizontal space.</simpara></note>
<simpara>Use a single space indentation for function (macro) arguments
when there are no arguments on the same line as the function name.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(filter
 even?
 (range 1 10))

(or
 ala
 bala
 portokala)

;; bad - two-space indent
(filter
  even?
  (range 1 10))

(or
  ala
  bala
  portokala)</programlisting>
<simpara>This may appear like some weird special rule to people without Lisp background, but the
reasoning behind it is quite simple. Function calls are
nothing but regular list literals and normally those are aligned in the same way as
other collection type literals when spanning multiple lines:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; list literal
(1
 2
 3)

;; vector literal
[1
 2
 3]

;; set literal
#{1
  2
  3}</programlisting>
<simpara>Admittedly, list literals are not very common in Clojure, that&#8217;s why it&#8217;s understandable
that for many people lists are nothing but an invocation syntax.</simpara>
<simpara>As a side benefit, function arguments are still aligned in this scenario as well. They
just happen to accidentally be aligned with the function name as well.</simpara>
<sidebar>
<title>Semantic Indentation vs Fixed Indentation</title>
<simpara>The guidelines to indent differently macros with body forms from
all other macro and function calls are collectively known as
"semantic indentation". Simply put, this means that the code
is indented differently, so that the indentation would give the
reader of the code some hints about its meaning.</simpara>
<simpara>The downside of this approach is that requires Clojure code formatters to be
smarter. They either need to process <literal>macro</literal> arglists and rely on the fact
that people named their parameters consistently, or process some additional
indentation metadata.</simpara>
<simpara>Some people in the Clojure community have argued that&#8217;s not worth it and
that everything should simply be indented in the same fashion. Here are
a few examples:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;;; Fixed Indentation
;;
;; macros
(when something
  (something-else))

(with-out-str
  (println "Hello, ")
  (println "world!"))

;; function call spanning two lines
(filter even?
  (range 1 10))

;; function call spanning three lines
(filter
  even?
  (range 1 10))</programlisting>
<simpara>This suggestion has certainly gotten some ground in the community, but it also
goes against much of the Lisp tradition and one of the primary goals of this style guide -
namely to optimize code for human consumption.</simpara>
<simpara>There&#8217;s one exception to the fixed indentation rule - data lists (those that are not a function invocation):</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;;; Fixed Indentation
;;
;; list literals
;; we still do
(1
 2
 3
 4
 5
 6)

;; and
(1 2 3
 4 5 6)

;; instead of
(1 2 3
  4 5 6)

;; or
(1
  2
  3
  4
  5
  6)</programlisting>
<simpara>This makes sure that lists are consistent with how other collection types are normally indented.</simpara>
</sidebar>
</section>
<section id="bindings_alignment_anchor_id_bindings_alignment_xreflabel_bindings_alignment">
<title>Bindings Alignment <anchor id="bindings-alignment" xreflabel="[bindings-alignment]"/></title>
<simpara>Vertically align <literal>let</literal> (and <literal>let</literal>-like) bindings.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(let [thing1 "some stuff"
      thing2 "other stuff"]
  (foo thing1 thing2))

;; bad
(let [thing1 "some stuff"
  thing2 "other stuff"]
  (foo thing1 thing2))</programlisting>
</section>
<section id="map_keys_alignment_anchor_id_map_keys_alignment_xreflabel_map_keys_alignment">
<title>Map Keys Alignment <anchor id="map-keys-alignment" xreflabel="[map-keys-alignment]"/></title>
<simpara>Align vertically map keys.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
{:thing1 thing1
 :thing2 thing2}

;; bad
{:thing1 thing1
:thing2 thing2}

;; bad
{:thing1 thing1
  :thing2 thing2}</programlisting>
</section>
<section id="line_endings_anchor_id_crlf_xreflabel_crlf">
<title>Line Endings <anchor id="crlf" xreflabel="[crlf]"/></title>
<simpara>Use Unix-style line endings.<footnote><simpara>*BSD/Solaris/Linux/macOS users are
covered by default, Windows users have to be extra careful.</simpara></footnote></simpara>
<tip>
<simpara>If you&#8217;re using Git you might want to add the following
configuration setting to protect your project from Windows line
endings creeping in:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ git config --global core.autocrlf true</programlisting>
</tip>
</section>
<section id="terminate_files_with_a_newline_anchor_id_terminate_files_with_a_newline_xreflabel_terminate_files_with_a_newline">
<title>Terminate Files With a Newline <anchor id="terminate-files-with-a-newline" xreflabel="[terminate-files-with-a-newline]"/></title>
<simpara>End each file with a newline.</simpara>
<tip><simpara>This should be done by through editor configuration, not manually.</simpara></tip>
</section>
<section id="bracket_spacing_anchor_id_bracket_spacing_xreflabel_bracket_spacing">
<title>Bracket Spacing <anchor id="bracket-spacing" xreflabel="[bracket-spacing]"/></title>
<simpara>If any text precedes an opening bracket(<literal>(</literal>, <literal>{</literal> and
<literal>[</literal>) or follows a closing bracket(<literal>)</literal>, <literal>}</literal> and <literal>]</literal>), separate that
text from that bracket with a space. Conversely, leave no space after
an opening bracket and before following text, or after preceding text
and before a closing bracket.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(foo (bar baz) quux)

;; bad
(foo(bar baz)quux)
(foo ( bar baz ) quux)</programlisting>
</section>
<section id="no_commas_in_sequential_collection_literals_anchor_id_no_commas_for_seq_literals_xreflabel_no_commas_for_seq_literals">
<title>No Commas in Sequential Collection Literals <anchor id="no-commas-for-seq-literals" xreflabel="[no-commas-for-seq-literals]"/></title>
<blockquote>
<attribution>
Alan Perlis
</attribution>
<simpara>Syntactic sugar causes semicolon cancer.</simpara>
</blockquote>
<simpara>Don&#8217;t use commas between the elements of sequential collection literals.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
[1 2 3]
(1 2 3)

;; bad
[1, 2, 3]
(1, 2, 3)</programlisting>
</section>
<section id="optional_commas_in_map_literals_anchor_id_opt_commas_in_map_literals_xreflabel_opt_commas_in_map_literals">
<title>Optional Commas in Map Literals <anchor id="opt-commas-in-map-literals" xreflabel="[opt-commas-in-map-literals]"/></title>
<simpara>Consider enhancing the readability of map literals via judicious use
of commas and line breaks.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
{:name "Bruce Wayne" :alter-ego "Batman"}

;; good and arguably a bit more readable
{:name "Bruce Wayne"
 :alter-ego "Batman"}

;; good and arguably more compact
{:name "Bruce Wayne", :alter-ego "Batman"}</programlisting>
</section>
<section id="gather_trailing_parentheses_anchor_id_gather_trailing_parens_xreflabel_gather_trailing_parens">
<title>Gather Trailing Parentheses <anchor id="gather-trailing-parens" xreflabel="[gather-trailing-parens]"/></title>
<simpara>Place all trailing parentheses on a single line instead of distinct lines.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good; single line
(when something
  (something-else))

;; bad; distinct lines
(when something
  (something-else)
)</programlisting>
</section>
<section id="empty_lines_between_top_level_forms_anchor_id_empty_lines_between_top_level_forms_xreflabel_empty_lines_between_top_level_forms">
<title>Empty Lines Between Top-Level Forms <anchor id="empty-lines-between-top-level-forms" xreflabel="[empty-lines-between-top-level-forms]"/></title>
<simpara>Use a single empty line between top-level forms.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def x ...)

(defn foo ...)

;; bad
(def x ...)
(defn foo ...)

;; bad
(def x ...)


(defn foo ...)</programlisting>
<simpara>An exception to the rule is the grouping of related ``def``s together.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def min-rows 10)
(def max-rows 20)
(def min-cols 15)
(def max-cols 30)</programlisting>
</section>
<section id="no_blank_lines_within_definition_forms_anchor_id_no_blank_lines_within_def_forms_xreflabel_no_blank_lines_within_def_forms">
<title>No Blank Lines Within Definition Forms <anchor id="no-blank-lines-within-def-forms" xreflabel="[no-blank-lines-within-def-forms]"/></title>
<simpara>Do not place blank lines in the middle of a function or
macro definition.  An exception can be made to indicate grouping of
pairwise constructs as found in e.g. <literal>let</literal> and <literal>cond</literal>, in case those don&#8217;t
fit on the same line.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn fibo-iter
  ([n] (fibo-iter 0 1 n))
  ([curr nxt n]
   (cond
     (zero? n) curr
     :else (recur nxt (+' curr nxt) (dec n)))))

;; okay - the line break delimits a cond pair
(defn fibo-iter
  ([n] (fibo-iter 0 1 n))
  ([curr nxt n]
   (cond
     (zero? n)
     curr

     :else
     (recur nxt (+' curr nxt) (dec n)))))

;; bad
(defn fibo-iter
  ([n] (fibo-iter 0 1 n))

  ([curr nxt n]
   (cond
     (zero? n) curr

     :else (recur nxt (+' curr nxt) (dec n)))))</programlisting>
<simpara>Occasionally, it might seem like a good idea to add a blank line
here and there in a longer function definition, but if you get to this
point you should also consider whether this long function isn&#8217;t doing
too much and could potentially be broken down.</simpara>
</section>
<section id="no_trailing_whitespace_anchor_id_no_trailing_whitespace_xreflabel_no_trailing_whitespace">
<title>No Trailing Whitespace <anchor id="no-trailing-whitespace" xreflabel="[no-trailing-whitespace]"/></title>
<simpara>Avoid trailing whitespace.</simpara>
</section>
<section id="one_file_per_namespace_anchor_id_one_file_per_namespace_xreflabel_one_file_per_namespace">
<title>One File per Namespace <anchor id="one-file-per-namespace" xreflabel="[one-file-per-namespace]"/></title>
<simpara>Use one file per namespace and one namespace per file.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(ns foo.bar)

;; bad
(ns foo.bar)
(ns baz.qux)

;; bad
(in-ns quux.quuz)
(in-ns quuz.corge)

;; bad
(ns foo.bar) or (in-ns foo.bar) in multiple files</programlisting>
</section>
</section>
<section id="namespace_declaration">
<title>Namespace Declaration</title>
<section id="no_single_segment_namespaces_anchor_id_no_single_segment_namespaces_xreflabel_no_single_segment_namespaces">
<title>No Single Segment Namespaces <anchor id="no-single-segment-namespaces" xreflabel="[no-single-segment-namespaces]"/></title>
<simpara>Avoid single-segment namespaces.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(ns example.ns)

;; bad
(ns example)</programlisting>
<simpara>Namespaces exist to disambiguate names. Using a single segment
namespace puts you in direct conflict with everyone else using single
segment namespaces, thus making it more likely you will conflict with
another code base.</simpara>
<simpara>In practice this means that libraries should never use single-segment
namespace to avoid namespace conflicts with other libraries.
Within your own private app of course, you can do whatever you like.</simpara>
<tip><simpara>It&#8217;s common practice to use the convention <literal>domain.library-name</literal>
or <literal>library-name.core</literal> for libraries with a single namespace in them.
Read on for more coverage of the namespace naming topic.</simpara></tip>
<simpara>There are <ulink url="https://github.com/bbatsov/clojure-style-guide/pull/100">other reasons</ulink>
why might want to avoid single-segment namespaces, so you should
think long and hard before making any use of them.</simpara>
</section>
<section id="namespace_segments_limit_anchor_id_namespace_segments_limit_xreflabel_namespace_segments_limit">
<title>Namespace Segments Limit <anchor id="namespace-segments-limit" xreflabel="[namespace-segments-limit]"/></title>
<simpara>Avoid the use of overly long namespaces (i.e., more than 5 segments).</simpara>
</section>
<section id="comprehensive_literal_ns_literal_form_anchor_id_comprehensive_ns_declaration_xreflabel_comprehensive_ns_declaration">
<title>Comprehensive <literal>ns</literal> Form <anchor id="comprehensive-ns-declaration" xreflabel="[comprehensive-ns-declaration]"/></title>
<simpara>Start every namespace with a comprehensive <literal>ns</literal> form, comprised of
``refer``s, ``require``s, and ``import``s, conventionally in that order.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns examples.ns
  (:refer-clojure :exclude [next replace remove])
  (:require [clojure.string :as s :refer [blank?]])
  (:import java.util.Date))</programlisting>
</section>
<section id="line_breaks_in_literal_ns_literal_anchor_id_line_break_ns_declaration_xreflabel_line_break_ns_declaration">
<title>Line Breaks in <literal>ns</literal> <anchor id="line-break-ns-declaration" xreflabel="[line-break-ns-declaration]"/></title>
<simpara>When there are multiple dependencies, you may want give each one its own line.
This facilitates sorting, readability, and cleaner diffs for dependency changes.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; better
(ns examples.ns
  (:require
   [clojure.string :as s :refer [blank?]]
   [clojure.set :as set]
   [clojure.java.shell :as sh])
  (:import
   java.util.Date
   java.text.SimpleDateFormat
   [java.util.concurrent Executors
                         LinkedBlockingQueue]))

;; good
(ns examples.ns
  (:require [clojure.string :as s :refer [blank?]]
            [clojure.set :as set]
            [clojure.java.shell :as sh])
  (:import java.util.Date
           java.text.SimpleDateFormat
           [java.util.concurrent Executors
                                 LinkedBlockingQueue]))

;; bad
(ns examples.ns
  (:require [clojure.string :as s :refer [blank?]] [clojure.set :as set] [clojure.java.shell :as sh])
  (:import java.util.Date java.text.SimpleDateFormat [java.util.concurrent Executors LinkedBlockingQueue]))</programlisting>
</section>
<section id="prefer_literal_require_literal_over_literal_use_literal_anchor_id_prefer_require_over_use_xreflabel_prefer_require_over_use">
<title>Prefer <literal>:require</literal> Over <literal>:use</literal> <anchor id="prefer-require-over-use" xreflabel="[prefer-require-over-use]"/></title>
<simpara>In the <literal>ns</literal> form prefer <literal>:require :as</literal> over <literal>:require :refer</literal> over <literal>:require
:refer :all</literal>.  Prefer <literal>:require</literal> over <literal>:use</literal>; the latter form should be
considered deprecated for new code.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(ns examples.ns
  (:require [clojure.zip :as zip]))

;; good
(ns examples.ns
  (:require [clojure.zip :refer [lefts rights]]))

;; acceptable as warranted
(ns examples.ns
  (:require [clojure.zip :refer :all]))

;; bad
(ns examples.ns
  (:use clojure.zip))</programlisting>
</section>
<section id="sort_requirements_and_imports_anchor_id_sort_requirements_and_imports_xreflabel_sort_requirements_and_imports">
<title>Sort Requirements and Imports <anchor id="sort-requirements-and-imports" xreflabel="[sort-requirements-and-imports]"/></title>
<simpara>In the <literal>ns</literal> form, sort your requirements and imports. This facilitates readability and avoids duplication, especially when the list of required / imported namespaces is very long.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(ns examples.ns
  (:require
   [baz.core :as baz]
   [clojure.java.shell :as sh]
   [clojure.set :as set]
   [clojure.string :as s :refer [blank?]]
   [foo.bar :as foo]))

;; bad
(ns examples.ns
  (:require
   [clojure.string :as s :refer [blank?]]
   [clojure.set :as set]
   [baz.core :as baz]
   [foo.bar :as foo]
   [clojure.java.shell :as sh]))</programlisting>
</section>
<section id="use_idiomatic_namespace_aliases">
<title>Use Idiomatic Namespace Aliases</title>
<simpara>Many core Clojure namespaces have idiomatic aliases that you&#8217;re
encouraged to use within your projects - e.g. the most common way to
require <literal>clojure.string</literal> is: <literal>[clojure.string :as str]</literal>.</simpara>
<note><simpara>This may appear to mask
<literal>clojure.core.str</literal>, but it doesn&#8217;t. It&#8217;s expected that
<literal>clojure.core/str</literal> and <literal>clojure.string/*</literal> to be used in a namespace as
<literal>str</literal> and <literal>str/whatever</literal> without conflict.</simpara></note>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(ns ... (:require [clojure.string :as str] ...)

(str/join ...)

;; not as good - just be idiomatic and use as `str/`
(ns ... (:require [clojure.string :as string] ...)

(string/join ...)</programlisting>
<simpara>Some common, idiomatic aliases are shown below:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Namespace</simpara></entry>
<entry align="left" valign="top"><simpara>Idiomatic Alias</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.edn</simpara></entry>
<entry align="left" valign="top"><simpara>edn</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.java.io</simpara></entry>
<entry align="left" valign="top"><simpara>io</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.java.shell</simpara></entry>
<entry align="left" valign="top"><simpara>sh</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.math</simpara></entry>
<entry align="left" valign="top"><simpara>math</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.pprint</simpara></entry>
<entry align="left" valign="top"><simpara>pp</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.set</simpara></entry>
<entry align="left" valign="top"><simpara>set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.spec.alpha</simpara></entry>
<entry align="left" valign="top"><simpara>spec</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.string</simpara></entry>
<entry align="left" valign="top"><simpara>str</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.walk</simpara></entry>
<entry align="left" valign="top"><simpara>walk</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.zip</simpara></entry>
<entry align="left" valign="top"><simpara>zip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.core.async</simpara></entry>
<entry align="left" valign="top"><simpara>as</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.core.matrix</simpara></entry>
<entry align="left" valign="top"><simpara>mat</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.data.csv</simpara></entry>
<entry align="left" valign="top"><simpara>csv</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.data.xml</simpara></entry>
<entry align="left" valign="top"><simpara>xml</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clojure.tools.logging</simpara></entry>
<entry align="left" valign="top"><simpara>log</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>cheshire.core</simpara></entry>
<entry align="left" valign="top"><simpara>json</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clj-yaml.core</simpara></entry>
<entry align="left" valign="top"><simpara>yaml</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>clj-http.client</simpara></entry>
<entry align="left" valign="top"><simpara>http</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>hugsql.core</simpara></entry>
<entry align="left" valign="top"><simpara>sql</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>java-time</simpara></entry>
<entry align="left" valign="top"><simpara>time</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="a_recipe_for_good_namespace_aliases">
<title>A Recipe for Good Namespace Aliases</title>
<simpara>Above we covered a handful of popular namespaces and their idiomatic aliases.
You might have noticed that those are a bit inconsistent:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>clojure.string</literal> becomes <literal>str</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>clojure.pprint</literal> becomes <literal>pp</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>clojure.walk</literal> becomes <literal>walk</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>clojure.spec.alpha</literal> becomes <literal>spec</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>It&#8217;s clear that the one thing they have in common is that they aim to be concise, but still carry some meaning (aliasing <literal>clojure.walk</literal> to <literal>w</literal> would
be concise, but won&#8217;t carry much meaning).</simpara>
<simpara>But what to do about all the other namespaces out there that don&#8217;t have idiomatic aliases? Well, you better be consistent in your approach to deriving aliases for them,
otherwise the people working on a shared Clojure codebase are going to experience a great deal of confusion. Here are a few rules that you should follow.<footnote><simpara>These guidelines are based on a <ulink url="https://stuartsierra.com/2015/05/10/clojure-namespace-aliases">blog post</ulink> by Stuart Sierra.</simpara></footnote></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Make the alias the same as the namespace name with the leading parts removed.
</simpara>
</listitem>
</orderedlist>
<programlisting language="clojure" linenumbering="unnumbered">(ns com.example.application
  (:require
   [clojure.java.io :as io]
   [clojure.string :as string]))</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Keep enough trailing parts to make each alias unique.
</simpara>
</listitem>
</orderedlist>
<programlisting language="clojure" linenumbering="unnumbered">[clojure.data.xml :as data.xml]
[clojure.xml :as xml]</programlisting>
<tip><simpara>Yes, namespace aliases can have dots in them. Make good use of them.</simpara></tip>
<orderedlist numeration="arabic">
<listitem>
<simpara>
Eliminate redundant words such as "core" and "clj" in aliases.
</simpara>
</listitem>
</orderedlist>
<programlisting language="clojure" linenumbering="unnumbered">[clj-http :as http]
[clj-time.core :as time]
[clj-time.format :as time.format]</programlisting>
</section>
<section id="use_consistent_namespace_aliases">
<title>Use Consistent Namespace Aliases</title>
<simpara>Across a project, it&#8217;s good to be consistent with namespace aliases; e.g., don&#8217;t require <literal>clojure.string</literal> as <literal>str</literal> in one namespace but <literal>string</literal> in another.
If you follow the previous two guidelines you&#8217;re basically covered, but if you opt for custom namespace aliasing scheme it&#8217;s still important to apply it
consistently within your projects.</simpara>
</section>
</section>
<section id="naming">
<title>Naming</title>
<blockquote>
<attribution>
Phil Karlton
</attribution>
<simpara>The only real difficulties in programming are cache invalidation and
naming things.</simpara>
</blockquote>
<section id="namespace_naming_schemas_anchor_id_naming_ns_naming_schemas_xreflabel_naming_ns_naming_schemas">
<title>Namespace Naming Schemas <anchor id="naming-ns-naming-schemas" xreflabel="[naming-ns-naming-schemas]"/></title>
<simpara>When naming namespaces favor the following two schemas:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>project.module</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>organization.project.module</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>When you&#8217;re following the <literal>project.module</literal> naming scheme and your project
has a single (implementation) namespace it&#8217;s common to name it <literal>project.core</literal>.
Avoid the <literal>project.core</literal> name in all other cases, as more informative names
are always a better idea.</simpara>
</section>
<section id="composite_word_namespace_segments_anchor_id_naming_namespace_composite_segments_xreflabel_naming_namespace_composite_segments">
<title>Composite Word Namespace Segments <anchor id="naming-namespace-composite-segments" xreflabel="[naming-namespace-composite-segments]"/></title>
<simpara>Use <literal>lisp-case</literal> in composite namespace segments (e.g. <literal>bruce.project-euler</literal>).</simpara>
<note><simpara>Many non-Lisp programming communities refer to <literal>lisp-case</literal> as
<literal>kebab-case</literal>, but we all know that Lisp existed way before kebab
was invented.</simpara></note>
</section>
<section id="functions_and_variables_anchor_id_naming_functions_and_variables_xreflabel_naming_functions_and_variables">
<title>Functions and Variables <anchor id="naming-functions-and-variables" xreflabel="[naming-functions-and-variables]"/></title>
<simpara>Use <literal>lisp-case</literal> for function and variable names.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def some-var ...)
(defn some-fun ...)

;; bad
(def someVar ...)
(defn somefun ...)
(def some_fun ...)</programlisting>
</section>
<section id="protocols_records_structs_and_types_anchor_id_naming_protocols_records_structs_and_types_xreflabel_naming_protocols_records_structs_and_types">
<title>Protocols, Records, Structs and Types <anchor id="naming-protocols-records-structs-and-types" xreflabel="[naming-protocols-records-structs-and-types]"/></title>
<simpara>Use <literal>CapitalCase</literal> for protocols, records, structs, and types. (Keep
acronyms like HTTP, RFC, XML uppercase.)</simpara>
<note><simpara><literal>CapitalCase</literal> is also known as <literal>UpperCamelCase, `CapitalWords</literal>
and <literal>PascalCase</literal>.</simpara></note>
</section>
<section id="predicate_methods_anchor_id_naming_predicates_xreflabel_naming_predicates">
<title>Predicate Methods <anchor id="naming-predicates" xreflabel="[naming-predicates]"/></title>
<simpara>The names of predicate methods (methods that return a boolean value)
should end in a question mark
(e.g., <literal>even?</literal>).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn palindrome? ...)

;; bad
(defn palindrome-p ...) ; Common Lisp style
(defn is-palindrome ...) ; Java style</programlisting>
</section>
<section id="unsafe_functions_anchor_id_naming_unsafe_functions_xreflabel_naming_unsafe_functions">
<title>Unsafe Functions <anchor id="naming-unsafe-functions" xreflabel="[naming-unsafe-functions]"/></title>
<simpara>The names of functions/macros that are not safe in STM transactions
should end with an exclamation mark (e.g. <literal>reset!</literal>).</simpara>
</section>
<section id="conversion_functions_anchor_id_naming_conversion_functions_xreflabel_naming_conversion_functions">
<title>Conversion Functions <anchor id="naming-conversion-functions" xreflabel="[naming-conversion-functions]"/></title>
<simpara>Use <literal>+-&gt;+</literal> instead of <literal>to</literal> in the names of conversion functions.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn f-&gt;c ...)

;; not so good
(defn f-to-c ...)</programlisting>
</section>
<section id="dynamic_vars_anchor_id_naming_dynamic_vars_xreflabel_naming_dynamic_vars">
<title>Dynamic Vars <anchor id="naming-dynamic-vars" xreflabel="[naming-dynamic-vars]"/></title>
<simpara>Use <literal>*earmuffs*</literal> for things intended for rebinding (ie. are dynamic).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def ^:dynamic *a* 10)

;; bad
(def ^:dynamic a 10)</programlisting>
</section>
<section id="constants_anchor_id_naming_constants_xreflabel_naming_constants">
<title>Constants <anchor id="naming-constants" xreflabel="[naming-constants]"/></title>
<simpara>Don&#8217;t use a special notation for constants; everything is assumed a constant
unless specified otherwise.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def max-size 10)

;; bad
(def MAX-SIZE 10) ; Java style
(def +max-size+ 10) ; Common Lisp style, global constant
(def *max-size* 10) ; Common Lisp style, global variable</programlisting>
<note><simpara>Famously <literal>\*clojure-version*</literal> defies this convention, but you should
treat this naming choice as a historical oddity and not as an example to
follow.</simpara></note>
</section>
<section id="unused_bindings_anchor_id_naming_unused_bindings_xreflabel_naming_unused_bindings">
<title>Unused Bindings <anchor id="naming-unused-bindings" xreflabel="[naming-unused-bindings]"/></title>
<simpara>Use <literal>+_+</literal> for destructuring targets and formal argument names whose
value will be ignored by the code at hand.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(let [[a b _ c] [1 2 3 4]]
  (println a b c))

(dotimes [_ 3]
  (println "Hello!"))

;; bad
(let [[a b c d] [1 2 3 4]]
  (println a b d))

(dotimes [i 3]
  (println "Hello!"))</programlisting>
<simpara>However, when it can help the understanding of your code, it can be useful to explicitly name unused arguments or maps you&#8217;re destructuring from. In this case, prepend the name with an underscore to explicitly signal that the variable is supposed to be unused.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn myfun1 [context _]
 (assoc context :foo "bar"))

(defn myfun2 [context {:keys [id]}]
 (assoc context :user-id id))

;; better
(defn myfun1 [context _user]
 (assoc context :foo "bar"))

(defn myfun2 [context {:keys [id] :as _user}]
 (assoc context :user-id id))</programlisting>
</section>
<section id="idiomatic_names_anchor_id_idiomatic_names_xreflabel_idiomatic_names">
<title>Idiomatic Names <anchor id="idiomatic-names" xreflabel="[idiomatic-names]"/></title>
<simpara>Follow ``clojure.core``'s example for idiomatic names like <literal>pred</literal> and <literal>coll</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>
in functions:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>f</literal>, <literal>g</literal>, <literal>h</literal> - function input
</simpara>
</listitem>
<listitem>
<simpara>
<literal>n</literal> - integer input usually a size
</simpara>
</listitem>
<listitem>
<simpara>
<literal>index</literal>, <literal>i</literal> - integer index
</simpara>
</listitem>
<listitem>
<simpara>
<literal>x</literal>, <literal>y</literal> - numbers
</simpara>
</listitem>
<listitem>
<simpara>
<literal>xs</literal> - sequence
</simpara>
</listitem>
<listitem>
<simpara>
<literal>m</literal> - map
</simpara>
</listitem>
<listitem>
<simpara>
<literal>s</literal> - string input
</simpara>
</listitem>
<listitem>
<simpara>
<literal>re</literal> - regular expression
</simpara>
</listitem>
<listitem>
<simpara>
<literal>sym</literal> - symbol
</simpara>
</listitem>
<listitem>
<simpara>
<literal>coll</literal> - a collection
</simpara>
</listitem>
<listitem>
<simpara>
<literal>pred</literal> - a predicate closure
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&amp; more</literal> - variadic input
</simpara>
</listitem>
<listitem>
<simpara>
<literal>xf</literal> - xform, a transducer
</simpara>
</listitem>
<listitem>
<simpara>
<literal>ns</literal> - namespace<footnote><simpara>Technically this will shadow the <literal>ns</literal> macro, but it&#8217;s extremely unlikely you&#8217;ll ever need it in the body of a function.</simpara></footnote>
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
in macros:
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>expr</literal> - an expression
</simpara>
</listitem>
<listitem>
<simpara>
<literal>body</literal> - a macro body
</simpara>
</listitem>
<listitem>
<simpara>
<literal>binding</literal> - a macro binding vector
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
in methods (when specified in <literal>defprotocol</literal>, <literal>deftype</literal>, <literal>defrecord</literal>, <literal>reify</literal>, etc):
</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>this</literal> - for the first argument, indicating a reference to the object - or alternatively, a consistent name which describes the object
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section id="functions">
<title>Functions</title>
<section id="optional_new_line_after_function_name_anchor_id_optional_new_line_after_fn_name_xreflabel_optional_new_line_after_fn_name">
<title>Optional New Line After Function Name <anchor id="optional-new-line-after-fn-name" xreflabel="[optional-new-line-after-fn-name]"/></title>
<simpara>Optionally omit the new line between the function name and argument
vector for <literal>defn</literal> when there is no docstring.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn foo
  [x]
  (bar x))

;; good
(defn foo [x]
  (bar x))

;; bad
(defn foo
  [x] (bar x))</programlisting>
</section>
<section id="multimethod_dispatch_val_placement_anchor_id_multimethod_dispatch_val_placement_xreflabel_multimethod_dispatch_val_placement">
<title>Multimethod Dispatch Val Placement <anchor id="multimethod-dispatch-val-placement" xreflabel="[multimethod-dispatch-val-placement]"/></title>
<simpara>Place the <literal>dispatch-val</literal> of a multimethod on the same line as the
function name.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defmethod foo :bar [x] (baz x))

(defmethod foo :bar
  [x]
  (baz x))

;; bad
(defmethod foo
  :bar
  [x]
  (baz x))

(defmethod foo
  :bar [x]
  (baz x))</programlisting>
</section>
<section id="one_line_functions">
<title>One-line Functions</title>
<simpara>Optionally omit the new line between the argument vector and a short
function body.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn foo [x]
  (bar x))

;; good for a small function body
(defn foo [x] (bar x))

;; good for multi-arity functions
(defn foo
  ([x] (bar x))
  ([x y]
   (if (predicate? x)
     (bar x)
     (baz x))))

;; bad
(defn foo
  [x] (if (predicate? x)
        (bar x)
        (baz x)))</programlisting>
</section>
<section id="multiple_arity_indentation_anchor_id_multiple_arity_indentation_xreflabel_multiple_arity_indentation">
<title>Multiple Arity Indentation <anchor id="multiple-arity-indentation" xreflabel="[multiple-arity-indentation]"/></title>
<simpara>Indent each arity form of a function definition vertically aligned with its
parameters.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn foo
  "I have two arities."
  ([x]
   (foo x 1))
  ([x y]
   (+ x y)))

;; bad - extra indentation
(defn foo
  "I have two arities."
  ([x]
    (foo x 1))
  ([x y]
    (+ x y)))</programlisting>
</section>
<section id="multiple_arity_order_anchor_id_multiple_arity_order_xreflabel_multiple_arity_order">
<title>Multiple Arity Order <anchor id="multiple-arity-order" xreflabel="[multiple-arity-order]"/></title>
<simpara>Sort the arities of a function
from fewest to most arguments. The common case of multi-arity
functions is that some K arguments fully specifies the function&#8217;s
behavior, and that arities N &lt; K partially apply the K arity, and
arities N &gt; K provide a fold of the K arity over varargs.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good - it's easy to scan for the nth arity
(defn foo
  "I have two arities."
  ([x]
   (foo x 1))
  ([x y]
   (+ x y)))

;; okay - the other arities are applications of the two-arity
(defn foo
  "I have two arities."
  ([x y]
   (+ x y))
  ([x]
   (foo x 1))
  ([x y z &amp; more]
   (reduce foo (foo x (foo y z)) more)))

;; bad - unordered for no apparent reason
(defn foo
  ([x] 1)
  ([x y z] (foo x (foo y z)))
  ([x y] (+ x y))
  ([w x y z &amp; more] (reduce foo (foo w (foo x (foo y z))) more)))</programlisting>
</section>
<section id="function_length_anchor_id_function_length_xreflabel_function_length">
<title>Function Length <anchor id="function-length" xreflabel="[function-length]"/></title>
<simpara>Avoid functions longer than 10 LOC (lines of code). Ideally, most
functions will be shorter than 5 LOC.</simpara>
</section>
<section id="function_positional_parameters_limit_anchor_id_function_positional_parameter_limit_xreflabel_function_positional_parameter_limit">
<title>Function Positional Parameters Limit <anchor id="function-positional-parameter-limit" xreflabel="[function-positional-parameter-limit]"/></title>
<simpara>Avoid parameter lists with more than three or four positional parameters.</simpara>
</section>
<section id="pre_and_post_conditions_anchor_id_pre_post_conditions_xreflabel_pre_post_conditions">
<title>Pre and Post Conditions <anchor id="pre-post-conditions" xreflabel="[pre-post-conditions]"/></title>
<simpara>Prefer function pre and post conditions to checks inside a function&#8217;s body.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn foo [x]
  {:pre [(pos? x)]}
  (bar x))

;; bad
(defn foo [x]
  (if (pos? x)
    (bar x)
    (throw (IllegalArgumentException. "x must be a positive number!")))</programlisting>
</section>
</section>
<section id="idioms">
<title>Idioms</title>
<section id="dynamic_namespace_manipulation_anchor_id_ns_fns_only_in_repl_xreflabel_ns_fns_only_in_repl">
<title>Dynamic Namespace Manipulation <anchor id="ns-fns-only-in-repl" xreflabel="[ns-fns-only-in-repl]"/></title>
<simpara>Avoid the use of namespace-manipulating functions like <literal>require</literal> and
<literal>refer</literal>. They are entirely unnecessary outside of a REPL
environment.</simpara>
</section>
<section id="forward_references_anchor_id_forward_references_xreflabel_forward_references">
<title>Forward References <anchor id="forward-references" xreflabel="[forward-references]"/></title>
<simpara>Avoid forward references.  They are occasionally necessary, but such occasions
are rare in practice.</simpara>
</section>
<section id="declare_anchor_id_declare_xreflabel_declare">
<title>Declare <anchor id="declare" xreflabel="[declare]"/></title>
<simpara>Use <literal>declare</literal> to enable forward references when forward references are
necessary.</simpara>
</section>
<section id="higher_order_functions_anchor_id_higher_order_fns_xreflabel_higher_order_fns">
<title>Higher-order Functions <anchor id="higher-order-fns" xreflabel="[higher-order-fns]"/></title>
<simpara>Prefer higher-order functions like <literal>map</literal> to <literal>loop/recur</literal>.</simpara>
</section>
<section id="vars_inside_functions_anchor_id_dont_def_vars_inside_fns_xreflabel_dont_def_vars_inside_fns">
<title>Vars Inside Functions <anchor id="dont-def-vars-inside-fns" xreflabel="[dont-def-vars-inside-fns]"/></title>
<simpara>Don&#8217;t define vars inside functions.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; very bad
(defn foo []
  (def x 5)
  ...)</programlisting>
</section>
<section id="shadowing_literal_clojure_core_literal_names_anchor_id_dont_shadow_clojure_core_xreflabel_dont_shadow_clojure_core">
<title>Shadowing <literal>clojure.core</literal> Names <anchor id="dont-shadow-clojure-core" xreflabel="[dont-shadow-clojure-core]"/></title>
<simpara>Don&#8217;t shadow <literal>clojure.core</literal> names with local bindings.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; bad - clojure.core/map must be fully qualified inside the function
(defn foo [map]
  ...)</programlisting>
</section>
<section id="alter_var_binding_anchor_id_alter_var_xreflabel_alter_var">
<title>Alter Var Binding <anchor id="alter-var" xreflabel="[alter-var]"/></title>
<simpara>Use <literal>alter-var-root</literal> instead of <literal>def</literal> to change the value of a var.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def thing 1) ; value of thing is now 1
; do some stuff with thing
(alter-var-root #'thing (constantly nil)) ; value of thing is now nil

;; bad
(def thing 1)
; do some stuff with thing
(def thing nil)
; value of thing is now nil</programlisting>
</section>
<section id="nil_punning_anchor_id_nil_punning_xreflabel_nil_punning">
<title>Nil Punning <anchor id="nil-punning" xreflabel="[nil-punning]"/></title>
<simpara>Use <literal>seq</literal> as a terminating condition to test whether a sequence is
empty (this technique is sometimes called <emphasis>nil punning</emphasis>).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn print-seq [s]
  (when (seq s)
    (prn (first s))
    (recur (rest s))))

;; bad
(defn print-seq [s]
  (when-not (empty? s)
    (prn (first s))
    (recur (rest s))))</programlisting>
</section>
<section id="converting_sequences_to_vectors_anchor_id_to_vector_xreflabel_to_vector">
<title>Converting Sequences to Vectors <anchor id="to-vector" xreflabel="[to-vector]"/></title>
<simpara>Prefer <literal>vec</literal> over <literal>into</literal> when you need to convert a sequence into a vector.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(vec some-seq)

;; bad
(into [] some-seq)</programlisting>
</section>
<section id="converting_something_to_boolean">
<title>Converting Something to Boolean</title>
<simpara>Use the <literal>boolean</literal> function if you need to convert something to an actual boolean value (<literal>true</literal> or <literal>false</literal>).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(boolean (foo bar))

;; bad
(if (foo bar) true false)</programlisting>
<note><simpara>Don&#8217;t forget that the only values in Clojure that are "falsey" are <literal>false</literal> and <literal>nil</literal>. Everything else
will evaluate to <literal>true</literal> when passed to the <literal>boolean</literal> function.</simpara></note>
<simpara>You&#8217;ll rarely need an actual boolean value in Clojure, but it&#8217;s useful to know how to obtain one when you do.</simpara>
</section>
<section id="literal_when_literal_vs_literal_if_literal_anchor_id_when_instead_of_single_branch_if_xreflabel_when_instead_of_single_branch_if">
<title><literal>when</literal> vs <literal>if</literal> <anchor id="when-instead-of-single-branch-if" xreflabel="[when-instead-of-single-branch-if]"/></title>
<simpara>Use <literal>when</literal> instead of <literal>if</literal> with just the truthy branch, as in <literal>(if condition (something...))</literal> or <literal>(if ... (do ...))</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(when pred
  (foo)
  (bar))

;; bad
(if pred
  (do
    (foo)
    (bar)))</programlisting>
</section>
<section id="literal_if_let_literal_anchor_id_if_let_xreflabel_if_let">
<title><literal>if-let</literal> <anchor id="if-let" xreflabel="[if-let]"/></title>
<simpara>Use <literal>if-let</literal> instead of <literal>let</literal> + <literal>if</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(if-let [result (foo x)]
  (something-with result)
  (something-else))

;; bad
(let [result (foo x)]
  (if result
    (something-with result)
    (something-else)))</programlisting>
</section>
<section id="literal_when_let_literal_anchor_id_when_let_xreflabel_when_let">
<title><literal>when-let</literal> <anchor id="when-let" xreflabel="[when-let]"/></title>
<simpara>Use <literal>when-let</literal> instead of <literal>let</literal> + <literal>when</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(when-let [result (foo x)]
  (do-something-with result)
  (do-something-more-with result))

;; bad
(let [result (foo x)]
  (when result
    (do-something-with result)
    (do-something-more-with result)))</programlisting>
</section>
<section id="literal_if_not_literal_anchor_id_if_not_xreflabel_if_not">
<title><literal>if-not</literal> <anchor id="if-not" xreflabel="[if-not]"/></title>
<simpara>Use <literal>if-not</literal> instead of <literal>(if (not ...) ...)</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(if-not pred
  (foo))

;; bad
(if (not pred)
  (foo))</programlisting>
</section>
<section id="literal_when_not_literal_anchor_id_when_not_xreflabel_when_not">
<title><literal>when-not</literal> <anchor id="when-not" xreflabel="[when-not]"/></title>
<simpara>Use <literal>when-not</literal> instead of <literal>(when (not ...) ...)</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(when-not pred
  (foo)
  (bar))

;; bad
(when (not pred)
  (foo)
  (bar))</programlisting>
</section>
<section id="literal_when_not_literal_vs_literal_if_not_literal_anchor_id_when_not_instead_of_single_branch_if_not_xreflabel_when_not_instead_of_single_branch_if_not">
<title><literal>when-not</literal> vs <literal>if-not</literal> <anchor id="when-not-instead-of-single-branch-if-not" xreflabel="[when-not-instead-of-single-branch-if-not]"/></title>
<simpara>Use <literal>when-not</literal> instead of <literal>(if-not ... (do ...))</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(when-not pred
  (foo)
  (bar))

;; bad
(if-not pred
  (do
    (foo)
    (bar)))</programlisting>
</section>
<section id="literal_not_literal_anchor_id_not_equal_xreflabel_not_equal">
<title><literal>not=</literal> <anchor id="not-equal" xreflabel="[not-equal]"/></title>
<simpara>Use <literal>not=</literal> instead of <literal>(not (= ...))</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(not= foo bar)

;; bad
(not (= foo bar))</programlisting>
</section>
<section id="literal_printf_literal_anchor_id_printf_xreflabel_printf">
<title><literal>printf</literal> <anchor id="printf" xreflabel="[printf]"/></title>
<simpara>Prefer <literal>printf</literal> over <literal>(print (format ...))</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(printf "Hello, %s!\n" name)

;; ok
(println (format "Hello, %s!" name))</programlisting>
</section>
<section id="flexible_comparison_functions">
<title>Flexible Comparison Functions</title>
<simpara>When doing comparisons, leverage the fact that Clojure&#8217;s functions <literal>&lt;</literal>,
<literal>&gt;</literal>, etc. accept a variable number of arguments.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(&lt; 5 x 10)

;; bad
(and (&gt; x 5) (&lt; x 10))</programlisting>
</section>
<section id="single_parameter_function_literal_anchor_id_single_param_fn_literal_xreflabel_single_param_fn_literal">
<title>Single Parameter Function Literal <anchor id="single-param-fn-literal" xreflabel="[single-param-fn-literal]"/></title>
<simpara>Prefer <literal>%</literal> over <literal>%1</literal> in function literals with only one parameter.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
#(Math/round %)

;; bad
#(Math/round %1)</programlisting>
</section>
<section id="multiple_parameters_function_literal_anchor_id_multiple_params_fn_literal_xreflabel_multiple_params_fn_literal">
<title>Multiple Parameters Function Literal <anchor id="multiple-params-fn-literal" xreflabel="[multiple-params-fn-literal]"/></title>
<simpara>Prefer <literal>%1</literal> over <literal>%</literal> in function literals with more than one parameter.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
#(Math/pow %1 %2)

;; bad
#(Math/pow % %2)</programlisting>
</section>
<section id="no_useless_anonymous_functions_anchor_id_no_useless_anonymous_fns_xreflabel_no_useless_anonymous_fns">
<title>No Useless Anonymous Functions <anchor id="no-useless-anonymous-fns" xreflabel="[no-useless-anonymous-fns]"/></title>
<simpara>Don&#8217;t wrap functions in anonymous functions when you don&#8217;t need to.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(filter even? (range 1 10))

;; bad
(filter #(even? %) (range 1 10))</programlisting>
</section>
<section id="no_multiple_forms_in_function_literals_anchor_id_no_multiple_forms_fn_literals_xreflabel_no_multiple_forms_fn_literals">
<title>No Multiple Forms in Function Literals <anchor id="no-multiple-forms-fn-literals" xreflabel="[no-multiple-forms-fn-literals]"/></title>
<simpara>Don&#8217;t use function literals if the function body will consist of
more than one form.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(fn [x]
  (println x)
  (* x 2))

;; bad (you need an explicit do form)
#(do (println %)
     (* % 2))</programlisting>
</section>
<section id="anonymous_functions_vs_literal_complement_literal_literal_comp_literal_and_literal_partial_literal">
<title>Anonymous Functions vs <literal>complement</literal>, <literal>comp</literal> and <literal>partial</literal></title>
<simpara>Prefer anonymous functions over <literal>complement</literal>, <literal>comp</literal> and <literal>partial</literal>, as this results
in simpler code most of the time.<footnote><simpara>You can read more on the subject <ulink url="https://ask.clojure.org/index.php/8373/when-should-prefer-comp-and-partial-to-anonymous-functions">here</ulink>.</simpara></footnote></simpara>
<section id="literal_complement_literal_anchor_id_complement_xreflabel_complement">
<title><literal>complement</literal> <anchor id="complement" xreflabel="[complement]"/></title>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(filter #(not (some-pred? %)) coll)

;; okish
(filter (complement some-pred?) coll)</programlisting>
</section>
<section id="literal_comp_literal_anchor_id_comp_xreflabel_comp">
<title><literal>comp</literal> <anchor id="comp" xreflabel="[comp]"/></title>
<programlisting language="clojure" linenumbering="unnumbered">;; Assuming `(:require [clojure.string :as str])`...

;; good
(map #(str/capitalize (str/trim %)) ["top " " test "])

;; okish
(map (comp str/capitalize str/trim) ["top " " test "])</programlisting>
<simpara><literal>comp</literal> is quite useful when composing transducer chains, though.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def xf
  (comp
    (filter odd?)
    (map inc)
    (take 5)))</programlisting>
</section>
<section id="literal_partial_literal_anchor_id_partial_xreflabel_partial">
<title><literal>partial</literal> <anchor id="partial" xreflabel="[partial]"/></title>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(map #(+ 5 %) (range 1 10))

;; okish
(map (partial + 5) (range 1 10))</programlisting>
</section>
</section>
<section id="threading_macros_anchor_id_threading_macros_xreflabel_threading_macros">
<title>Threading Macros <anchor id="threading-macros" xreflabel="[threading-macros]"/></title>
<simpara>Prefer the use of the threading macros <literal>+-&gt;+</literal> (thread-first) and <literal>+-&gt;&gt;+</literal>
(thread-last) to heavy form nesting.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(-&gt; [1 2 3]
    reverse
    (conj 4)
    prn)

;; not as good
(prn (conj (reverse [1 2 3])
           4))

;; good
(-&gt;&gt; (range 1 10)
     (filter even?)
     (map (partial * 2)))

;; not as good
(map (partial * 2)
     (filter even? (range 1 10)))</programlisting>
</section>
<section id="threading_macros_and_optional_parentheses">
<title>Threading Macros and Optional Parentheses</title>
<simpara>Parentheses are not required when using the threading macros for functions having no argument specified, so use them only when necessary.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(-&gt; x fizz :foo first frob)

;; bad; parens add clutter and are not needed
(-&gt; x (fizz) (:foo) (first) (frob))

;; good, parens are necessary with an arg
(-&gt; x
    (fizz a b)
    :foo
    first
    (frob x y))</programlisting>
</section>
<section id="threading_macros_alignment">
<title>Threading Macros Alignment</title>
<simpara>The arguments to the threading macros <literal>+-&gt;+</literal> (thread-first) and <literal>+-&gt;&gt;+</literal>
(thread-last) should line up.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(-&gt;&gt; (range)
     (filter even?)
     (take 5))

;; bad
(-&gt;&gt; (range)
  (filter even?)
  (take 5))</programlisting>
</section>
<section id="default_literal_cond_literal_branch_anchor_id_else_keyword_in_cond_xreflabel_else_keyword_in_cond">
<title>Default <literal>cond</literal> Branch <anchor id="else-keyword-in-cond" xreflabel="[else-keyword-in-cond]"/></title>
<simpara>Use <literal>:else</literal> as the catch-all test expression in <literal>cond</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(cond
  (neg? n) "negative"
  (pos? n) "positive"
  :else "zero")

;; bad
(cond
  (neg? n) "negative"
  (pos? n) "positive"
  true "zero")</programlisting>
</section>
<section id="literal_condp_literal_vs_literal_cond_literal_anchor_id_condp_xreflabel_condp">
<title><literal>condp</literal> vs <literal>cond</literal> <anchor id="condp" xreflabel="[condp]"/></title>
<simpara>Prefer <literal>condp</literal> instead of <literal>cond</literal> when the predicate &amp; expression don&#8217;t
change.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :thirty
  :else :dunno)

;; much better
(condp = x
  10 :ten
  20 :twenty
  30 :thirty
  :dunno)</programlisting>
</section>
<section id="literal_case_literal_vs_literal_cond_condp_literal_anchor_id_case_xreflabel_case">
<title><literal>case</literal> vs <literal>cond/condp</literal> <anchor id="case" xreflabel="[case]"/></title>
<simpara>Prefer <literal>case</literal> instead of <literal>cond</literal> or <literal>condp</literal> when test expressions are
compile-time constants.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :forty
  :else :dunno)

;; better
(condp = x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)

;; best
(case x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)</programlisting>
</section>
<section id="short_forms_in_cond_anchor_id_short_forms_in_cond_xreflabel_short_forms_in_cond">
<title>Short Forms In Cond <anchor id="short-forms-in-cond" xreflabel="[short-forms-in-cond]"/></title>
<simpara>Use short forms in <literal>cond</literal> and related.  If not possible give visual
hints for the pairwise grouping with comments or empty lines.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(cond
  (test1) (action1)
  (test2) (action2)
  :else   (default-action))

;; ok-ish
(cond
  ;; test case 1
  (test1)
  (long-function-name-which-requires-a-new-line
    (complicated-sub-form
      (-&gt; 'which-spans multiple-lines)))

  ;; test case 2
  (test2)
  (another-very-long-function-name
    (yet-another-sub-form
      (-&gt; 'which-spans multiple-lines)))

  :else
  (the-fall-through-default-case
    (which-also-spans 'multiple
                      'lines)))</programlisting>
</section>
<section id="set_as_predicate_anchor_id_set_as_predicate_xreflabel_set_as_predicate">
<title>Set As Predicate <anchor id="set-as-predicate" xreflabel="[set-as-predicate]"/></title>
<simpara>Use a <literal>set</literal> as a predicate when appropriate.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(remove #{1} [0 1 2 3 4 5])

;; bad
(remove #(= % 1) [0 1 2 3 4 5])

;; good
(count (filter #{\a \e \i \o \u} "mary had a little lamb"))

;; bad
(count (filter #(or (= % \a)
                    (= % \e)
                    (= % \i)
                    (= % \o)
                    (= % \u))
               "mary had a little lamb"))</programlisting>
</section>
<section id="literal_inc_literal_and_literal_dec_literal_anchor_id_inc_and_dec_xreflabel_inc_and_dec">
<title><literal>inc</literal> and <literal>dec</literal> <anchor id="inc-and-dec" xreflabel="[inc-and-dec]"/></title>
<simpara>Use <literal>(inc x)</literal> &amp; <literal>(dec x)</literal> instead of <literal>(+ x 1)</literal> and <literal>(- x 1)</literal>.</simpara>
</section>
<section id="literal_pos_literal_and_literal_neg_literal_anchor_id_pos_and_neg_xreflabel_pos_and_neg">
<title><literal>pos?</literal> and <literal>neg?</literal> <anchor id="pos-and-neg" xreflabel="[pos-and-neg]"/></title>
<simpara>Use <literal>(pos? x)</literal>, <literal>(neg? x)</literal> &amp; <literal>(zero? x)</literal> instead of <literal>(&gt; x 0)</literal>,
<literal>(&lt; x 0)</literal> &amp; <literal>(= x 0)</literal>.</simpara>
</section>
<section id="literal_list_literal_vs_literal_cons_literal_anchor_id_list_star_instead_of_nested_cons_xreflabel_list_star_instead_of_nested_cons">
<title><literal>list*</literal> vs <literal>cons</literal> <anchor id="list-star-instead-of-nested-cons" xreflabel="[list-star-instead-of-nested-cons]"/></title>
<simpara>Use <literal>list*</literal> instead of a series of nested <literal>cons</literal> invocations.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(list* 1 2 3 [4 5])

;; bad
(cons 1 (cons 2 (cons 3 [4 5])))</programlisting>
</section>
<section id="sugared_java_interop_anchor_id_sugared_java_interop_xreflabel_sugared_java_interop">
<title>Sugared Java Interop <anchor id="sugared-java-interop" xreflabel="[sugared-java-interop]"/></title>
<simpara>Use the sugared Java interop forms.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;;; object creation
;; good
(java.util.ArrayList. 100)

;; bad
(new java.util.ArrayList 100)

;;; static method invocation
;; good
(Math/pow 2 10)

;; bad
(. Math pow 2 10)

;;; instance method invocation
;; good
(.substring "hello" 1 3)

;; bad
(. "hello" substring 1 3)

;;; static field access
;; good
Integer/MAX_VALUE

;; bad
(. Integer MAX_VALUE)

;;; instance field access
;; good
(.someField some-object)

;; bad
(. some-object someField)</programlisting>
</section>
<section id="compact_metadata_notation_for_true_flags_anchor_id_compact_metadata_notation_for_true_flags_xreflabel_compact_metadata_notation_for_true_flags">
<title>Compact Metadata Notation For True Flags <anchor id="compact-metadata-notation-for-true-flags" xreflabel="[compact-metadata-notation-for-true-flags]"/></title>
<simpara>Use the compact metadata notation for metadata that contains only
slots whose keys are keywords and whose value is boolean <literal>true</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def ^:private a 5)

;; bad
(def ^{:private true} a 5)</programlisting>
</section>
<section id="private_anchor_id_private_xreflabel_private">
<title>Private <anchor id="private" xreflabel="[private]"/></title>
<simpara>Denote private parts of your code.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn- private-fun [] ...)

(def ^:private private-var ...)

;; bad
(defn private-fun [] ...) ; not private at all

(defn ^:private private-fun [] ...) ; overly verbose

(def private-var ...) ; not private at all</programlisting>
</section>
<section id="access_private_var_anchor_id_access_private_var_xreflabel_access_private_var">
<title>Access Private Var <anchor id="access-private-var" xreflabel="[access-private-var]"/></title>
<simpara>To access a private var (e.g. for testing), use the <literal>@#'some.ns/var</literal> form.</simpara>
</section>
<section id="attach_metadata_carefully_anchor_id_attach_metadata_carefully_xreflabel_attach_metadata_carefully">
<title>Attach Metadata Carefully <anchor id="attach-metadata-carefully" xreflabel="[attach-metadata-carefully]"/></title>
<simpara>Be careful regarding what exactly you attach metadata to.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; we attach the metadata to the var referenced by `a`
(def ^:private a {})
(meta a) ;=&gt; nil
(meta #'a) ;=&gt; {:private true}

;; we attach the metadata to the empty hash-map value
(def a ^:private {})
(meta a) ;=&gt; {:private true}
(meta #'a) ;=&gt; nil</programlisting>
</section>
</section>
<section id="data_structures">
<title>Data Structures</title>
<blockquote>
<attribution>
Alan J. Perlis
</attribution>
<simpara>It is better to have 100 functions operate on one data structure
than to have 10 functions operate on 10 data structures.</simpara>
</blockquote>
<section id="avoid_lists_anchor_id_avoid_lists_xreflabel_avoid_lists">
<title>Avoid Lists <anchor id="avoid-lists" xreflabel="[avoid-lists]"/></title>
<simpara>Avoid the use of lists for generic data storage (unless a list is
exactly what you need).</simpara>
</section>
<section id="keywords_for_hash_keys_anchor_id_keywords_for_hash_keys_xreflabel_keywords_for_hash_keys">
<title>Keywords For Hash Keys <anchor id="keywords-for-hash-keys" xreflabel="[keywords-for-hash-keys]"/></title>
<simpara>Prefer the use of keywords for hash keys.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
{:name "Bruce" :age 30}

;; bad
{"name" "Bruce" "age" 30}</programlisting>
</section>
<section id="literal_collection_syntax_anchor_id_literal_col_syntax_xreflabel_literal_col_syntax">
<title>Literal Collection Syntax <anchor id="literal-col-syntax" xreflabel="[literal-col-syntax]"/></title>
<simpara>Prefer the use of the literal collection syntax where
applicable. However, when defining sets, only use literal syntax
when the values are compile-time constants.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
[1 2 3]
#{1 2 3}
(hash-set (func1) (func2)) ; values determined at runtime

;; bad
(vector 1 2 3)
(hash-set 1 2 3)
#{(func1) (func2)} ; will throw runtime exception if (func1) = (func2)</programlisting>
</section>
<section id="avoid_index_based_collection_access_anchor_id_avoid_index_based_coll_access_xreflabel_avoid_index_based_coll_access">
<title>Avoid Index Based Collection Access <anchor id="avoid-index-based-coll-access" xreflabel="[avoid-index-based-coll-access]"/></title>
<simpara>Avoid accessing collection members by index whenever possible.</simpara>
</section>
<section id="keywords_as_functions_for_map_values_retrieval_anchor_id_keywords_as_fn_to_get_map_values_xreflabel_keywords_as_fn_to_get_map_values">
<title>Keywords as Functions for Map Values Retrieval <anchor id="keywords-as-fn-to-get-map-values" xreflabel="[keywords-as-fn-to-get-map-values]"/></title>
<simpara>Prefer the use of keywords as functions for retrieving values from
maps, where applicable.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def m {:name "Bruce" :age 30})

;; good
(:name m)

;; more verbose than necessary
(get m :name)

;; bad - susceptible to NullPointerException
(m :name)</programlisting>
</section>
<section id="collections_as_functions_anchor_id_colls_as_fns_xreflabel_colls_as_fns">
<title>Collections as Functions <anchor id="colls-as-fns" xreflabel="[colls-as-fns]"/></title>
<simpara>Leverage the fact that most collections are functions of their elements.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(filter #{\a \e \o \i \u} "this is a test")

;; bad - too ugly to share</programlisting>
</section>
<section id="keywords_as_functions_anchor_id_keywords_as_fns_xreflabel_keywords_as_fns">
<title>Keywords as Functions <anchor id="keywords-as-fns" xreflabel="[keywords-as-fns]"/></title>
<simpara>Leverage the fact that keywords can be used as functions of a collection.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">((juxt :a :b) {:a "ala" :b "bala"})</programlisting>
</section>
<section id="avoid_transient_collections_anchor_id_avoid_transient_colls_xreflabel_avoid_transient_colls">
<title>Avoid Transient Collections <anchor id="avoid-transient-colls" xreflabel="[avoid-transient-colls]"/></title>
<simpara>Avoid the use of transient collections, except for
performance-critical portions of the code.</simpara>
</section>
<section id="avoid_java_collections_anchor_id_avoid_java_colls_xreflabel_avoid_java_colls">
<title>Avoid Java Collections <anchor id="avoid-java-colls" xreflabel="[avoid-java-colls]"/></title>
<simpara>Avoid the use of Java collections.</simpara>
</section>
<section id="avoid_java_arrays_anchor_id_avoid_java_arrays_xreflabel_avoid_java_arrays">
<title>Avoid Java Arrays <anchor id="avoid-java-arrays" xreflabel="[avoid-java-arrays]"/></title>
<simpara>Avoid the use of Java arrays, except for interop scenarios and
performance-critical code dealing heavily with primitive types.</simpara>
</section>
</section>
<section id="types_amp_records">
<title>Types &amp; Records</title>
<section id="record_constructors_anchor_id_record_constructors_xreflabel_record_constructors">
<title>Record Constructors <anchor id="record-constructors" xreflabel="[record-constructors]"/></title>
<simpara>Don&#8217;t use the interop syntax to
construct type and record instances.  <literal>deftype</literal> and <literal>defrecord</literal>
automatically create constructor functions. Use those instead of
the interop syntax, as they make it clear that you&#8217;re dealing with a
<literal>deftype</literal> or a <literal>defrecord</literal>. See <ulink url="https://stuartsierra.com/2015/05/17/clojure-record-constructors">this
article</ulink>
for more details.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defrecord Foo [a b])
(deftype Bar [a b])

;; good
(-&gt;Foo 1 2)
(map-&gt;Foo {:b 4 :a 3})
(-&gt;Bar 1 2)

;; bad
(Foo. 1 2)
(Bar. 1 2)</programlisting>
<simpara>Note that <literal>deftype</literal> doesn&#8217;t define the <literal>+map-&gt;Type+</literal>
  constructor. It&#8217;s available only for records.</simpara>
</section>
<section id="custom_record_constructors_anchor_id_custom_record_constructors_xreflabel_custom_record_constructors">
<title>Custom Record Constructors <anchor id="custom-record-constructors" xreflabel="[custom-record-constructors]"/></title>
<simpara>Add custom type/record constructors when needed (e.g. to validate
properties on record creation). See <ulink url="https://stuartsierra.com/2015/05/17/clojure-record-constructors">this
article</ulink>
for more details.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defrecord Customer [id name phone email])

(defn make-customer
  "Creates a new customer record."
  [{:keys [name phone email]}]
  {:pre [(string? name)
         (valid-phone? phone)
         (valid-email? email)]}
  (-&gt;Customer (next-id) name phone email))</programlisting>
<simpara>Feel free to adopt whatever naming convention or structure you&#8217;d like for such custom constructors.</simpara>
</section>
<section id="custom_record_constructors_naming_anchor_id_custom_record_constructors_naming_xreflabel_custom_record_constructors_naming">
<title>Custom Record Constructors Naming <anchor id="custom-record-constructors-naming" xreflabel="[custom-record-constructors-naming]"/></title>
<simpara>Don&#8217;t override the auto-generated type/record constructor functions.
People expect them to have a certain behaviour and changing this behaviour
violates the principle of least surprise. See <ulink url="https://stuartsierra.com/2015/05/17/clojure-record-constructors">this
article</ulink>
for more details.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defrecord Foo [num])

;; good
(defn make-foo
  [num]
  {:pre [(pos? num)]}
  (-&gt;Foo num))

;; bad
(defn -&gt;Foo
  [num]
  {:pre [(pos? num)]}
  (Foo. num))</programlisting>
</section>
</section>
<section id="mutation">
<title>Mutation</title>
<section id="refs_anchor_id_refs_xreflabel_refs">
<title>Refs <anchor id="Refs" xreflabel="[Refs]"/></title>
<section id="literal_io_literal_macro_anchor_id_refs_io_macro_xreflabel_refs_io_macro">
<title><literal>io!</literal> Macro <anchor id="refs-io-macro" xreflabel="[refs-io-macro]"/></title>
<simpara>Consider wrapping all I/O calls with the <literal>io!</literal> macro to avoid nasty
surprises if you accidentally end up calling such code in a
transaction.</simpara>
</section>
<section id="avoid_literal_ref_set_literal_anchor_id_refs_avoid_ref_set_xreflabel_refs_avoid_ref_set">
<title>Avoid <literal>ref-set</literal> <anchor id="refs-avoid-ref-set" xreflabel="[refs-avoid-ref-set]"/></title>
<simpara>Avoid the use of <literal>ref-set</literal> whenever possible.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def r (ref 0))

;; good
(dosync (alter r + 5))

;; bad
(dosync (ref-set r 5))</programlisting>
</section>
<section id="small_transactions_anchor_id_refs_small_transactions_xreflabel_refs_small_transactions">
<title>Small Transactions <anchor id="refs-small-transactions" xreflabel="[refs-small-transactions]"/></title>
<simpara>Try to keep the size of transactions (the amount of work encapsulated in them)
as small as possible.</simpara>
</section>
<section id="avoid_short_long_transactions_with_same_ref_anchor_id_refs_avoid_short_long_transactions_with_same_ref_xreflabel_refs_avoid_short_long_transactions_with_same_ref">
<title>Avoid Short Long Transactions With Same Ref <anchor id="refs-avoid-short-long-transactions-with-same-ref" xreflabel="[refs-avoid-short-long-transactions-with-same-ref]"/></title>
<simpara>Avoid having both short- and long-running transactions interacting
with the same Ref.</simpara>
</section>
</section>
<section id="agents_anchor_id_agents_xreflabel_agents">
<title>Agents <anchor id="Agents" xreflabel="[Agents]"/></title>
<section id="agents_send_anchor_id_agents_send_xreflabel_agents_send">
<title>Agents Send <anchor id="agents-send" xreflabel="[agents-send]"/></title>
<simpara>Use <literal>send</literal> only for actions that are CPU bound and don&#8217;t block on I/O
or other threads.</simpara>
</section>
<section id="agents_send_off_anchor_id_agents_send_off_xreflabel_agents_send_off">
<title>Agents Send Off <anchor id="agents-send-off" xreflabel="[agents-send-off]"/></title>
<simpara>Use <literal>send-off</literal> for actions that might block, sleep, or otherwise tie
up the thread.</simpara>
</section>
</section>
<section id="atoms_anchor_id_atoms_xreflabel_atoms">
<title>Atoms <anchor id="Atoms" xreflabel="[Atoms]"/></title>
<section id="no_updates_within_transactions_anchor_id_atoms_no_update_within_transactions_xreflabel_atoms_no_update_within_transactions">
<title>No Updates Within Transactions <anchor id="atoms-no-update-within-transactions" xreflabel="[atoms-no-update-within-transactions]"/></title>
<simpara>Avoid atom updates inside STM transactions.</simpara>
</section>
<section id="prefer_literal_swap_literal_over_literal_reset_literal_anchor_id_atoms_prefer_swap_over_reset_xreflabel_atoms_prefer_swap_over_reset">
<title>Prefer <literal>swap!</literal> over <literal>reset!</literal> <anchor id="atoms-prefer-swap-over-reset" xreflabel="[atoms-prefer-swap-over-reset]"/></title>
<simpara>Try to use <literal>swap!</literal> rather than <literal>reset!</literal>, where possible.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def a (atom 0))

;; good
(swap! a + 5)

;; not as good
(reset! a 5)</programlisting>
</section>
</section>
</section>
<section id="math">
<title>Math</title>
<section id="prefer_literal_clojure_math_literal_functions_over_interop_anchor_id_prefer_clojure_math_over_interop_xreflabel_prefer_clojure_math_over_interop">
<title>Prefer <literal>clojure.math</literal> Functions Over Interop <anchor id="prefer-clojure-math-over-interop" xreflabel="[prefer-clojure-math-over-interop]"/></title>
<simpara>Prefer math functions from <literal>clojure.math</literal> over (Java) interop or rolling your own.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(clojure.math/pow 2 5)

;; okish
(Math/pow 2 5)</programlisting>
<simpara>The JDK package <literal>java.lang.Math</literal> provides access to many useful math
functions. Prior to version 1.11, Clojure relied on using these via interop, but this had
issues with discoverability, primitive performance, higher order application,
and portability. The new <literal>clojure.math</literal> namespace provides wrapper functions for
the methods available in <literal>java.lang.Math</literal> for <literal>long</literal> and <literal>double</literal> overloads with fast
primitive invocation.</simpara>
</section>
</section>
<section id="strings">
<title>Strings</title>
<section id="prefer_literal_clojure_string_literal_functions_over_interop_anchor_id_prefer_clojure_string_over_interop_xreflabel_prefer_clojure_string_over_interop">
<title>Prefer <literal>clojure.string</literal> Functions Over Interop <anchor id="prefer-clojure-string-over-interop" xreflabel="[prefer-clojure-string-over-interop]"/></title>
<simpara>Prefer string manipulation functions from <literal>clojure.string</literal> over Java interop or rolling your own.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(clojure.string/upper-case "bruce")

;; bad
(.toUpperCase "bruce")</programlisting>
<note><simpara>Several new functions were added to <literal>clojure.string</literal> in Clojure
1.8 (<literal>index-of</literal>, <literal>last-index-of</literal>, <literal>starts-with?</literal>, <literal>ends-with?</literal> and
<literal>includes?</literal>). You should avoid using those if you need to support
older Clojure releases.</simpara></note>
</section>
</section>
<section id="exceptions">
<title>Exceptions</title>
<section id="reuse_existing_exception_types_anchor_id_reuse_existing_exception_types_xreflabel_reuse_existing_exception_types">
<title>Reuse Existing Exception Types <anchor id="reuse-existing-exception-types" xreflabel="[reuse-existing-exception-types]"/></title>
<simpara>Reuse existing exception types. Idiomatic Clojure code&#8201;&#8212;&#8201;when it does
throw an exception&#8201;&#8212;&#8201;throws an exception of a standard type
(e.g. <literal>java.lang.IllegalArgumentException</literal>,
<literal>java.lang.UnsupportedOperationException</literal>,
<literal>java.lang.IllegalStateException</literal>, <literal>java.io.IOException</literal>).</simpara>
</section>
<section id="prefer_literal_with_open_literal_over_literal_finally_literal_anchor_id_prefer_with_open_over_finally_xreflabel_prefer_with_open_over_finally">
<title>Prefer <literal>with-open</literal> Over <literal>finally</literal> <anchor id="prefer-with-open-over-finally" xreflabel="[prefer-with-open-over-finally]"/></title>
<simpara>Favor <literal>with-open</literal> over <literal>finally</literal>.</simpara>
</section>
</section>
<section id="macros">
<title>Macros</title>
<section id="don_8217_t_write_a_macro_if_a_function_will_do_anchor_id_dont_write_macro_if_fn_will_do_xreflabel_dont_write_macro_if_fn_will_do">
<title>Don&#8217;t Write a Macro If a Function Will Do <anchor id="dont-write-macro-if-fn-will-do" xreflabel="[dont-write-macro-if-fn-will-do]"/></title>
<simpara>Don&#8217;t write a macro if a function will do.</simpara>
</section>
<section id="write_macro_usage_before_writing_the_macro_anchor_id_write_macro_usage_before_writing_the_macro_xreflabel_write_macro_usage_before_writing_the_macro">
<title>Write Macro Usage before Writing the Macro <anchor id="write-macro-usage-before-writing-the-macro" xreflabel="[write-macro-usage-before-writing-the-macro]"/></title>
<simpara>Create an example of a macro usage first and the macro afterwards.</simpara>
</section>
<section id="break_complicated_macros_anchor_id_break_complicated_macros_xreflabel_break_complicated_macros">
<title>Break Complicated Macros <anchor id="break-complicated-macros" xreflabel="[break-complicated-macros]"/></title>
<simpara>Break complicated macros into smaller functions whenever possible.</simpara>
</section>
<section id="macros_as_syntactic_sugar_anchor_id_macros_as_syntactic_sugar_xreflabel_macros_as_syntactic_sugar">
<title>Macros as Syntactic Sugar <anchor id="macros-as-syntactic-sugar" xreflabel="[macros-as-syntactic-sugar]"/></title>
<simpara>A macro should usually just provide syntactic sugar and the core of
the macro should be a plain function. Doing so will improve
composability.</simpara>
</section>
<section id="syntax_quoted_forms_anchor_id_syntax_quoted_forms_xreflabel_syntax_quoted_forms">
<title>Syntax Quoted Forms <anchor id="syntax-quoted-forms" xreflabel="[syntax-quoted-forms]"/></title>
<simpara>Prefer syntax-quoted forms over building lists manually.</simpara>
</section>
</section>
<section id="common_metadata">
<title>Common Metadata</title>
<simpara>In this section we&#8217;ll go over some common metadata for namespaces and
vars that Clojure development tools can leverage.</simpara>
<section id="literal_added_literal">
<title><literal>:added</literal></title>
<simpara>The most common way to document when a public API was added to a
library is via the <literal>:added</literal> metadata.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ^{:added "0.5"} foo
  42)

(ns foo.bar
  "A very useful ns."
  {:added "0.8"})

(defn ^{:added "0.5"} foo
  (bar))</programlisting>
<tip><simpara>If you&#8217;re into SemVer, it&#8217;s a good idea to omit the patch version.
This means you should use <literal>0.5</literal> instead of <literal>0.5.0</literal>. This applies
for all metadata data that&#8217;s version related.</simpara></tip>
</section>
<section id="literal_changed_literal">
<title><literal>:changed</literal></title>
<simpara>The most common way to document when a public API was changed in a
library is via the <literal>:changed</literal> metadata. This metadata makes sense only for
vars and you should be using it sparingly, as changing the behavior of
a public API is generally a bad idea.</simpara>
<simpara>Still, if you decide to do it, it&#8217;s best to make that clear to the API
users.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(def ^{:added "0.5"
       :changed "0.6"} foo
  43)</programlisting>
</section>
<section id="literal_deprecated_literal">
<title><literal>:deprecated</literal></title>
<simpara>The most common way to mark deprecated public APIs is via the <literal>:deprecated</literal>
metadata. Normally you&#8217;d use as the value the version in which something
was deprecated in case of versioned software (e.g. a library) or simply
<literal>true</literal> in the case of unversioned software (e.g. some web application).</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;;; good
;;
;; in case we have a version
(def ^{:deprecated "0.5"} foo
  "Use `bar` instead."
  42)

(ns foo.bar
  "A deprecated ns."
  {:deprecated "0.8"})

(defn ^{:deprecated "0.5"} foo
  (bar))

;; otherwise
(defn ^:deprecated foo
  (bar))

;;; bad
;;
;; using the docstring to signal deprecation
(def foo
  "DEPRECATED: Use `bar` instead."
  42)

(ns foo.bar
  "DEPRECATED: A deprecated ns.")</programlisting>
</section>
<section id="literal_superseded_by_literal">
<title><literal>:superseded-by</literal></title>
<simpara>Often you&#8217;d combine <literal>:deprecated</literal> with <literal>:superseded-by</literal>, as there would be
some newer API that supersedes whatever got deprecated.</simpara>
<simpara>Typically for vars you&#8217;ll use a non-qualified name if the replacement lives
in the same namespace, and a fully-qualified name otherwise.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; in case we have a version
(def ^{:deprecated "0.5"
       :superseded-by "bar"} foo
  "Use `bar` instead."
  42)

(ns foo.bar
  "A deprecated ns."
  {:deprecated "0.8"
   :superseded-by "foo.baz"})

(defn ^{:deprecated "0.5"
        :superseded-by "bar"} foo
  (bar))

;; otherwise
(defn ^{:deprecated true
        :superseded-by "bar"} foo
  (bar))</programlisting>
<tip><simpara>You can also consider adding <literal>:supersedes</literal> metadata to the newer APIs, basically the inverse of <literal>:superseded-by</literal>.</simpara></tip>
</section>
<section id="literal_see_also_literal">
<title><literal>:see-also</literal></title>
<simpara>From time to time you might want to point out some related vars/namespaces that the users of your library might be interested in.
The most common way to do so would be via the <literal>:see-also</literal> metadata, which takes a vector of related items.
When talking about vars - items in the same namespace don&#8217;t need to fully qualified.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; refers to vars in the same ns
(def ^{:see-also ["bar" "baz"]} foo
  "A very useful var."
  42)

;; refers to vars in some other ns
(defn ^{:see-also ["top.bar" "top.baz"]} foo
  (bar))</programlisting>
<note><simpara>Many Clojure programming tools will also try to extract references to other vars from the docstring, but it&#8217;s both
simpler and more explicit to use the <literal>:see-also</literal> metadata instead.</simpara></note>
</section>
<section id="literal_no_doc_literal">
<title><literal>:no-doc</literal></title>
<simpara>Documentation tools like <ulink url="https://github.com/weavejester/codox#metadata-options">Codox</ulink> like <ulink url="https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#hiding-namespaces-vars-in-documentation">cljdoc</ulink> recognize <literal>:no-doc</literal> metadata.
When a var or a namespace has <literal>:no-doc</literal> metadata, it indicates to these tools that it should be excluded from generated API docs.</simpara>
<simpara>To exclude an entire namespace from API docs:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns ^:no-doc my-library.impl
  "Internal implementation details")

...</programlisting>
<simpara>To exclude vars within a documented namespace:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(ns my-library.api)

;; private functions do not get documented
(defn- clearly-private []
  ...)

;; nor do public functions with :no-doc metadata
(defn ^:no-doc shared-helper []
  ...)

;; this function will be documented
(defn api-fn1
  "I am useful to the public"
  []
  ...)</programlisting>
</section>
<section id="indentation_metadata">
<title>Indentation Metadata</title>
<simpara>Unlike other Lisp dialects, Clojure doesn&#8217;t have a standard metadata format to specify the indentation of macros.
CIDER proposed a tool-agnostic <ulink url="https://docs.cider.mx/cider/indent_spec.html">indentation specification</ulink> based on metadata in 2015.<footnote><simpara>This was first introduced in CIDER 0.10</simpara></footnote> Here&#8217;s a simple example:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; refers to vars in the same ns
(defmacro with-in-str
  "[DOCSTRING]"
  {:style/indent 1}
  [s &amp; body]
  ...cut for brevity...)</programlisting>
<simpara>This instructs the indentation engine that this is a macro with one ordinary parameter and a body after it.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; without metadata (indented as a regular function)
(dop-iin-str some-string
             foo
             bar
             baz)

;; with metadata (indented as macro with one special param and a body)
(with-in-str some-string
  foo
  bar
  baz)</programlisting>
<simpara>Unfortunately, as of 2020 there&#8217;s still no widespread adoption of <literal>:style/indent</literal> and many editors and IDEs would just
hardcode the indentation rules for common macros.</simpara>
<note><simpara>This approach to indentation ("semantic indentation") is a contested topic in the Clojure community, due to the
need for the additional metadata and tooling support. Despite the long tradition of that approach in the Lisp community
in general, some people argue to just stop treating functions and macros differently and simply indent everything with a fixed
indentation. <ulink url="https://tonsky.me/blog/clojurefmt/">This article</ulink> is one popular presentation of that alternative approach.</simpara></note>
</section>
</section>
<section id="comments">
<title>Comments</title>
<blockquote>
<attribution>
Steve McConnell
</attribution>
<simpara>Good code is its own best documentation. As you&#8217;re about to add a
comment, ask yourself, "How can I improve the code so that this
comment isn&#8217;t needed?" Improve the code and then document it to make
it even clearer.</simpara>
</blockquote>
<section id="self_explanatory_code">
<title>Self-Explanatory Code</title>
<simpara>Endeavor to make your code as self-explanatory as possible.
If you fail to achieve this follow the rest of the guidelines in this section.</simpara>
</section>
<section id="heading_comments_anchor_id_four_semicolons_for_heading_comments_xreflabel_four_semicolons_for_heading_comments">
<title>Heading Comments <anchor id="four-semicolons-for-heading-comments" xreflabel="[four-semicolons-for-heading-comments]"/></title>
<simpara>Write heading comments with at least four semicolons. Those typically serve to outline/separate
major section of code, or to describe important ideas. Often you&#8217;d have a section comment followed
by a bunch of top-level comments.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;;;; Section Comment/Heading

;;; Foo...
;;; Bar...
;;; Baz...</programlisting>
</section>
<section id="top_level_comments_anchor_id_three_semicolons_for_top_level_comments_xreflabel_three_semicolons_for_top_level_comments">
<title>Top-Level Comments <anchor id="three-semicolons-for-top-level-comments" xreflabel="[three-semicolons-for-top-level-comments]"/></title>
<simpara>Write top-level comments with three semicolons.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;;; I'm a top-level comment.
;;; I live outside any definition.

(defn foo [])</programlisting>
<note><simpara>While the classic Lisp tradition dictates the use of <literal>;;;</literal> for
top-level comments, you&#8217;ll find plenty of Clojure code in the wild
that&#8217;s using <literal>;;</literal> or even <literal>;</literal>.</simpara></note>
</section>
<section id="code_fragment_line_comments_anchor_id_two_semicolons_for_code_fragment_xreflabel_two_semicolons_for_code_fragment">
<title>Code Fragment (Line) Comments <anchor id="two-semicolons-for-code-fragment" xreflabel="[two-semicolons-for-code-fragment]"/></title>
<simpara>Write comments on a particular fragment of code before that fragment
and aligned with it, using two semicolons.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn foo [x]
  ;; I'm a line/code fragment comment.
  x)</programlisting>
<note><simpara>While the classic Lisp tradition dictates the use of <literal>;;</literal> for
line comments, you&#8217;ll find plenty of Clojure code in the wild
that&#8217;s using only <literal>;</literal>.</simpara></note>
</section>
<section id="margin_inline_comments_anchor_id_one_semicolon_for_margin_comments_xreflabel_one_semicolon_for_margin_comments">
<title>Margin (Inline) Comments <anchor id="one-semicolon-for-margin-comments" xreflabel="[one-semicolon-for-margin-comments]"/></title>
<simpara>Write margin comments with one semicolon.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn foo [x]
  x ; I'm a line/code fragment comment.
  )</programlisting>
<simpara>Avoid using those in situations that would result in hanging closing parentheses.</simpara>
</section>
<section id="semicolon_space_anchor_id_semicolon_space_xreflabel_semicolon_space">
<title>Semicolon Space <anchor id="semicolon-space" xreflabel="[semicolon-space]"/></title>
<simpara>Always have at least one space between the semicolon
and the text that follows it.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;;;; Frob Grovel

;;; This section of code has some important implications:
;;;   1. Foo.
;;;   2. Bar.
;;;   3. Baz.

(defn fnord [zarquon]
  ;; If zob, then veeblefitz.
  (quux zot
        mumble             ; Zibblefrotz.
        frotz))</programlisting>
</section>
<section id="english_syntax_anchor_id_english_syntax_xreflabel_english_syntax">
<title>English Syntax <anchor id="english-syntax" xreflabel="[english-syntax]"/></title>
<simpara>Comments longer than a word begin with a capital letter and use
punctuation. Separate sentences with
<ulink url="https://en.wikipedia.org/wiki/Sentence_spacing">one space</ulink>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; This is a good comment.

;; this is a bad comment</programlisting>
<simpara>Obviously punctuation is not the most important thing about
a comment, but a bit of extra effort results in better experience
for the readers of our comments.</simpara>
</section>
<section id="no_superfluous_comments_anchor_id_no_superfluous_comments_xreflabel_no_superfluous_comments">
<title>No Superfluous Comments <anchor id="no-superfluous-comments" xreflabel="[no-superfluous-comments]"/></title>
<simpara>Avoid superfluous comments.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; bad
(inc counter) ; increments counter by one</programlisting>
</section>
<section id="comment_upkeep_anchor_id_comment_upkeep_xreflabel_comment_upkeep">
<title>Comment Upkeep <anchor id="comment-upkeep" xreflabel="[comment-upkeep]"/></title>
<simpara>Keep existing comments up-to-date. An outdated comment is worse than no comment
at all.</simpara>
</section>
<section id="literal___literal_reader_macro_anchor_id_dash_underscore_reader_macro_xreflabel_dash_underscore_reader_macro">
<title><literal>#_</literal> Reader Macro <anchor id="dash-underscore-reader-macro" xreflabel="[dash-underscore-reader-macro]"/></title>
<simpara>Prefer the use of the <literal>#_</literal> reader macro over a regular comment when
you need to comment out a particular form.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(+ foo #_(bar x) delta)

;; bad
(+ foo
   ;; (bar x)
   delta)</programlisting>
</section>
<section id="refactor_don_8217_t_comment_anchor_id_refactor_dont_comment_xreflabel_refactor_dont_comment">
<title>Refactor, Don&#8217;t Comment <anchor id="refactor-dont-comment" xreflabel="[refactor-dont-comment]"/></title>
<blockquote>
<attribution>
Russ Olsen
</attribution>
<simpara>Good code is like a good joke - it needs no explanation.</simpara>
</blockquote>
<simpara>Avoid writing comments to explain bad code. Refactor the code to
make it self-explanatory. ("Do, or do not. There is no try." --Yoda)</simpara>
</section>
<section id="comment_annotations">
<title>Comment Annotations</title>
<section id="annotate_above_anchor_id_annotate_above_xreflabel_annotate_above">
<title>Annotate Above <anchor id="annotate-above" xreflabel="[annotate-above]"/></title>
<simpara>Annotations should usually be written on the line immediately above
the relevant code.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn some-fun
  []
  ;; FIXME: Replace baz with the newer bar.
  (baz))

;; bad
;; FIXME: Replace baz with the newer bar.
(defn some-fun
  []
  (baz))</programlisting>
</section>
<section id="annotate_keywords_anchor_id_annotate_keywords_xreflabel_annotate_keywords">
<title>Annotate Keywords <anchor id="annotate-keywords" xreflabel="[annotate-keywords]"/></title>
<simpara>The annotation keyword is followed by a colon and a space, then a note
describing the problem.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn some-fun
  []
  ;; FIXME: Replace baz with the newer bar.
  (baz))

;; bad - no colon after annotation
(defn some-fun
  []
  ;; FIXME Replace baz with the newer bar.
  (baz))

;; bad - no space after colon
(defn some-fun
  []
  ;; FIXME:Replace baz with the newer bar.
  (baz))</programlisting>
</section>
<section id="indent_annotations_anchor_id_indent_annotations_xreflabel_indent_annotations">
<title>Indent Annotations <anchor id="indent-annotations" xreflabel="[indent-annotations]"/></title>
<simpara>If multiple lines are required to describe the problem, subsequent
lines should be indented as much as the first one.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn some-fun
  []
  ;; FIXME: This has crashed occasionally since v1.2.3. It may
  ;;        be related to the BarBazUtil upgrade. (xz 13-1-31)
  (baz))

;; bad
(defn some-fun
  []
  ;; FIXME: This has crashed occasionally since v1.2.3. It may
  ;; be related to the BarBazUtil upgrade. (xz 13-1-31)
  (baz))</programlisting>
</section>
<section id="sign_and_date_annotations_anchor_id_sign_and_date_annotations_xreflabel_sign_and_date_annotations">
<title>Sign and Date Annotations <anchor id="sign-and-date-annotations" xreflabel="[sign-and-date-annotations]"/></title>
<simpara>Tag the annotation with your initials and a date so its relevance can
be easily verified.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn some-fun
  []
  ;; FIXME: This has crashed occasionally since v1.2.3. It may
  ;;        be related to the BarBazUtil upgrade. (xz 13-1-31)
  (baz))</programlisting>
</section>
<section id="rare_margin_eol_annotations_anchor_id_rare_eol_annotations_xreflabel_rare_eol_annotations">
<title>Rare Margin (EOL) Annotations <anchor id="rare-eol-annotations" xreflabel="[rare-eol-annotations]"/></title>
<simpara>In cases where the problem is so obvious that any documentation would
be redundant, annotations may be left at the end of the offending line
with no note. This usage should be the exception and not the rule.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defn bar
  []
  (sleep 100)) ; OPTIMIZE</programlisting>
</section>
<section id="literal_todo_literal_anchor_id_todo_xreflabel_todo">
<title><literal>TODO</literal> <anchor id="todo" xreflabel="[todo]"/></title>
<simpara>Use <literal>TODO</literal> to note missing features or functionality that should be
added at a later date.</simpara>
</section>
<section id="literal_fixme_literal_anchor_id_fixme_xreflabel_fixme">
<title><literal>FIXME</literal> <anchor id="fixme" xreflabel="[fixme]"/></title>
<simpara>Use <literal>FIXME</literal> to note broken code that needs to be fixed.</simpara>
</section>
<section id="literal_optimize_literal_anchor_id_optimize_xreflabel_optimize">
<title><literal>OPTIMIZE</literal> <anchor id="optimize" xreflabel="[optimize]"/></title>
<simpara>Use <literal>OPTIMIZE</literal> to note slow or inefficient code that may cause
performance problems.</simpara>
</section>
<section id="literal_hack_literal_anchor_id_hack_xreflabel_hack">
<title><literal>HACK</literal> <anchor id="hack" xreflabel="[hack]"/></title>
<simpara>Use <literal>HACK</literal> to note "code smells" where questionable coding practices
were used and should be refactored away.</simpara>
</section>
<section id="literal_review_literal_anchor_id_review_xreflabel_review">
<title><literal>REVIEW</literal> <anchor id="review" xreflabel="[review]"/></title>
<simpara>Use <literal>REVIEW</literal> to note anything that should be looked at to confirm it
is working as intended. For example: <literal>REVIEW: Are we sure this is how the
client does X currently?</literal></simpara>
</section>
<section id="document_custom_annotations_anchor_id_document_annotations_xreflabel_document_annotations">
<title>Document Custom Annotations <anchor id="document-annotations" xreflabel="[document-annotations]"/></title>
<simpara>Use other custom annotation keywords if it feels appropriate, but be
sure to document them in your project&#8217;s <literal>README</literal> or similar.</simpara>
</section>
</section>
</section>
<section id="documentation">
<title>Documentation</title>
<simpara>Docstrings are the primary way to document Clojure code. Many definition forms
(e.g. <literal>def</literal>, <literal>defn</literal>, <literal>defmacro</literal>, <literal>ns</literal>)
support docstrings and usually it&#8217;s a good idea to make good use of them, regardless
of whether the var in question is something public or private.</simpara>
<simpara>If a definition form doesn&#8217;t support docstrings directly you can still supply them via
the <literal>:doc</literal> metadata attribute.</simpara>
<simpara>This section outlines some of the common conventions and best
practices for documenting Clojure code.</simpara>
<section id="prefer_docstrings_anchor_id_prefer_docstrings_xreflabel_prefer_docstrings">
<title>Prefer Docstrings <anchor id="prefer-docstrings" xreflabel="[prefer-docstrings]"/></title>
<simpara>If a form supports docstrings directly prefer them over using <literal>:doc</literal> metadata:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn foo
  "This function doesn't do much."
  []
  ...)

(ns foo.bar.core
  "That's an awesome library.")

;; bad
(defn foo
  ^{:doc "This function doesn't do much."}
  []
  ...)

(ns ^{:doc "That's an awesome library.")
  foo.bar.core)</programlisting>
</section>
<section id="docstring_summary_anchor_id_docstring_summary_xreflabel_docstring_summary">
<title>Docstring Summary <anchor id="docstring-summary" xreflabel="[docstring-summary]"/></title>
<simpara>Let the first line in the docstring be a complete, capitalized
sentence which concisely describes the var in question. This makes it
easy for tooling (Clojure editors and IDEs) to display a short a summary of
the docstring at various places.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn frobnitz
  "This function does a frobnitz.
  It will do gnorwatz to achieve this, but only under certain
  circumstances."
  []
  ...)

;; bad
(defn frobnitz
  "This function does a frobnitz. It will do gnorwatz to
  achieve this, but only under certain circumstances."
  []
  ...)</programlisting>
</section>
<section id="leverage_markdown_in_docstrings_anchor_id_markdown_docstrings_xreflabel_markdown_docstrings">
<title>Leverage Markdown in Docstrings <anchor id="markdown-docstrings" xreflabel="[markdown-docstrings]"/></title>
<simpara>Important tools such as <ulink url="https://github.com/cljdoc/cljdoc/blob/master/doc/userguide/for-library-authors.adoc#docstrings">cljdoc</ulink> support Markdown in docstrings so leverage it for nicely formatted documentation.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn qzuf-number
  "Computes the [Qzuf number](https://wikipedia.org/qzuf) of the `coll`.
  Supported options in `opts`:

  | key           | description |
  | --------------|-------------|
  | `:finite-uni?`| Assume finite universe; default: `false`
  | `:complex?`   | If OK to return a [complex number](https://en.wikipedia.org/wiki/Complex_number); default: `false`
  | `:timeout`    | Throw an exception if the computation doesn't finish within `:timeout` milliseconds; default: `nil`

  Example:
  ```clojure
  (when (neg? (qzuf-number [1 2 3] {:finite-uni? true}))
    (throw (RuntimeException. \"Error in the Universe!\")))
  ```"
  [coll opts]
  ...)</programlisting>
</section>
<section id="document_positional_arguments_anchor_id_document_pos_arguments_xreflabel_document_pos_arguments">
<title>Document Positional Arguments <anchor id="document-pos-arguments" xreflabel="[document-pos-arguments]"/></title>
<simpara>Document all positional arguments, and wrap them them with backticks
(`) so that editors and IDEs can identify them and potentially provide extra
functionality for them.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn watsitz
  "Watsitz takes a `frob` and converts it to a znoot.
  When the `frob` is negative, the znoot becomes angry."
  [frob]
  ...)

;; bad
(defn watsitz
  "Watsitz takes a frob and converts it to a znoot.
  When the frob is negative, the znoot becomes angry."
  [frob]
  ...)</programlisting>
</section>
<section id="document_references_anchor_id_document_references_xreflabel_document_references">
<title>Document References <anchor id="document-references" xreflabel="[document-references]"/></title>
<simpara>Wrap any var references in the docstring with ` so that tooling
can identify them. Wrap them with <literal>[[..]]</literal> if you want to link to them.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn wombat
  "Acts much like `clojure.core/identity` except when it doesn't.
  Takes `x` as an argument and returns that. If it feels like it.
  See also [[kangaroo]]."
  [x]
  ...)

;; bad
(defn wombat
  "Acts much like clojure.core/identity except when it doesn't.
  Takes `x` as an argument and returns that. If it feels like it.
  See also kangaroo."
  [x]
  ...)</programlisting>
</section>
<section id="docstring_grammar_anchor_id_docstring_grammar_xreflabel_docstring_grammar">
<title>Docstring Grammar <anchor id="docstring-grammar" xreflabel="[docstring-grammar]"/></title>
<simpara>Docstrings should be composed of well-formed English sentences. Every sentence
should start with a capitalized word, be grammatically coherent, and end
with appropriate punctuation. Sentences should be separated with a single space.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def foo
  "All sentences should end with a period (or maybe an exclamation mark).
  The sentence should be followed by a space, unless it concludes the docstring.")

;; bad
(def foo
  "all sentences should end with a period (or maybe an exclamation mark).
  The sentence should be followed by a space, unless it concludes the docstring.")</programlisting>
</section>
<section id="docstring_indentation_anchor_id_docstring_indentation_xreflabel_docstring_indentation">
<title>Docstring Indentation <anchor id="docstring-indentation" xreflabel="[docstring-indentation]"/></title>
<simpara>Indent multi-line docstrings by two spaces.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(ns my.ns
  "It is actually possible to document a ns.
  It's a nice place to describe the purpose of the namespace and maybe even
  the overall conventions used. Note how _not_ indenting the docstring makes
  it easier for tooling to display it correctly.")

;; bad
(ns my.ns
  "It is actually possible to document a ns.
It's a nice place to describe the purpose of the namespace and maybe even
the overall conventions used. Note how _not_ indenting the docstring makes
it easier for tooling to display it correctly.")</programlisting>
</section>
<section id="docstring_leading_trailing_whitespace_anchor_id_docstring_leading_trailing_whitespace_xreflabel_docstring_leading_trailing_whitespace">
<title>Docstring Leading Trailing Whitespace <anchor id="docstring-leading-trailing-whitespace" xreflabel="[docstring-leading-trailing-whitespace]"/></title>
<simpara>Neither start nor end your docstrings with any whitespace.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(def foo
  "I'm so awesome."
  42)

;; bad
(def silly
  "    It's just silly to start a docstring with spaces.
  Just as silly as it is to end it with a bunch of them.      "
  42)</programlisting>
</section>
<section id="place_docstring_after_function_name_anchor_id_docstring_after_fn_name_xreflabel_docstring_after_fn_name">
<title>Place Docstring After Function Name <anchor id="docstring-after-fn-name" xreflabel="[docstring-after-fn-name]"/></title>
<simpara>When adding a docstring&#8201;&#8212;&#8201;especially to a function using the above form&#8201;&#8212;&#8201;take
care to correctly place the docstring after the function name, not after the
argument vector.  The latter is not invalid syntax and won&#8217;t cause an error,
but includes the string as a form in the function body without attaching it to
the var as documentation.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(defn foo
  "docstring"
  [x]
  (bar x))

;; bad
(defn foo [x]
  "docstring"
  (bar x))</programlisting>
<note>
<simpara>Place docstrings for <literal>defprotocol</literal> methods <emphasis>after</emphasis> the argument vector:</simpara>
<programlisting language="clojure" linenumbering="unnumbered">(defprotocol MyProtocol
  "MyProtocol docstring"
  (foo [this x y z]
    "foo docstring")
  (bar [this]
    "bar docstring"))</programlisting>
</note>
</section>
</section>
<section id="testing">
<title>Testing</title>
<section id="test_directory_structure_anchor_id_test_directory_structure_xreflabel_test_directory_structure">
<title>Test Directory Structure <anchor id="test-directory-structure" xreflabel="[test-directory-structure]"/></title>
<simpara>Store your tests in a separate directory, typically <literal>test/yourproject/</literal> (as
opposed to <literal>src/yourproject/</literal>). Your build tool is responsible for making
them available in the contexts where they are necessary; most templates
will do this for you automatically.</simpara>
</section>
<section id="test_namespace_naming_anchor_id_test_ns_naming_xreflabel_test_ns_naming">
<title>Test Namespace Naming <anchor id="test-ns-naming" xreflabel="[test-ns-naming]"/></title>
<simpara>Name your ns <literal>yourproject.something-test</literal>, a file which usually lives in
<literal>test/yourproject/something_test.clj</literal> (or <literal>.cljc</literal>, <literal>cljs</literal>).</simpara>
</section>
<section id="test_naming_anchor_id_test_naming_xreflabel_test_naming">
<title>Test Naming <anchor id="test-naming" xreflabel="[test-naming]"/></title>
<simpara>When using <literal>clojure.test</literal>, define your tests
with <literal>deftest</literal> and name them <literal>something-test</literal>.</simpara>
<programlisting language="clojure" linenumbering="unnumbered">;; good
(deftest something-test ...)

;; bad
(deftest something-tests ...)
(deftest test-something ...)
(deftest something ...)</programlisting>
</section>
</section>
<section id="library_organization">
<title>Library Organization</title>
<section id="library_coordinates_anchor_id_lib_coordinates_xreflabel_lib_coordinates">
<title>Library Coordinates <anchor id="lib-coordinates" xreflabel="[lib-coordinates]"/></title>
<simpara>If you are publishing libraries to be used by others, make sure to
follow the <ulink url="https://central.sonatype.org/pages/choosing-your-coordinates.html">Central Repository
guidelines</ulink>
for choosing your <literal>groupId</literal> and <literal>artifactId</literal>. This helps to prevent
name conflicts and facilitates the widest possible use. A good
example is <ulink url="https://github.com/stuartsierra/component">Component</ulink> - its
coordinates are <literal>com.stuartsierra/component</literal>.</simpara>
<simpara>Another approach that&#8217;s popular in the wild is to use a project (or organization)
name as the <literal>groupId</literal> instead of domain name. Examples of such naming would be:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>cider/cider-nrepl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>nrepl/nrepl</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>nrepl/drawbridge</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>clj-commons/fs</literal>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="minimize_dependencies_anchor_id_lib_min_dependencies_xreflabel_lib_min_dependencies">
<title>Minimize Dependencies <anchor id="lib-min-dependencies" xreflabel="[lib-min-dependencies]"/></title>
<simpara>Avoid unnecessary dependencies. For example, a three-line utility
function copied into a project is usually better than a dependency
that drags in hundreds of vars you do not plan to use.</simpara>
</section>
<section id="tool_agnostic_anchor_id_lib_core_separate_from_tools_xreflabel_lib_core_separate_from_tools">
<title>Tool-agnostic <anchor id="lib-core-separate-from-tools" xreflabel="[lib-core-separate-from-tools]"/></title>
<simpara>Deliver core functionality and integration points in separate
artifacts.  That way, consumers can consume your library without
being constrained by your unrelated tooling preferences. For example,
<ulink url="https://github.com/stuartsierra/component">Component</ulink> provides
core functionality, and
<ulink url="https://github.com/stuartsierra/reloaded">reloaded</ulink> provides leiningen
integration.</simpara>
</section>
</section>
<section id="existential">
<title>Existential</title>
<section id="be_functional_anchor_id_be_functional_xreflabel_be_functional">
<title>Be Functional <anchor id="be-functional" xreflabel="[be-functional]"/></title>
<simpara>Code in a functional way, using mutation only when it makes sense.</simpara>
</section>
<section id="be_consistent_anchor_id_be_consistent_xreflabel_be_consistent">
<title>Be Consistent <anchor id="be-consistent" xreflabel="[be-consistent]"/></title>
<simpara>Be consistent. In an ideal world, be consistent with these guidelines.</simpara>
</section>
<section id="common_sense_anchor_id_common_sense_xreflabel_common_sense">
<title>Common Sense <anchor id="common-sense" xreflabel="[common-sense]"/></title>
<simpara>Use common sense.</simpara>
</section>
</section>
<section id="tools">
<title>Tools</title>
<simpara>One problem with style guides is that it&#8217;s often hard to remember all the guidelines
and to apply them consistently. We&#8217;re only humans, after all. Fortunately,
there are a bunch of tools that can do most of the work for us.</simpara>
<tip><simpara>It&#8217;s a great idea run such tools as part of your continuous integration (CI).
This ensure that all the code in one project is consistent with the style you&#8217;re
aiming for.</simpara></tip>
<section id="lint_tools">
<title>Lint Tools</title>
<simpara>There are some lint tools created by the Clojure community that might aid you
in your endeavor to write idiomatic Clojure code.</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/jonase/kibit">kibit</ulink> is a static code analyzer for
Clojure which uses <ulink url="https://github.com/clojure/core.logic">core.logic</ulink> to
search for patterns of code for which there might exist a more idiomatic
function or macro.
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/borkdude/clj-kondo">clj-kondo</ulink> is a linter that detects
a wide number of discouraged patterns and suggests improvements, based on this
style guide.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="code_formatters">
<title>Code Formatters</title>
<simpara>While most Clojure editors and IDEs can format the code, according to the layout guidelines
outlined here, it&#8217;s always handy to have some command-line code formatting tools. There are
a couple of options for Clojure that do a great job when it comes to formatting the code
as suggested in this guide:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/weavejester/cljfmt">cljfmt</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/greglook/cljstyle">cljstyle</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://github.com/kkinnear/zprint">zprint</ulink> (the documentation for configuring it to use the community formatting rules is <ulink url="https://github.com/kkinnear/zprint/blob/master/doc/options/community.md">here</ulink>)
</simpara>
</listitem>
</itemizedlist>
<note><simpara>When it comes to editors - Emacs&#8217;s <literal>clojure-mode</literal> by default will format the code exactly as outlined in the guide.
Other editors might require some configuration tweaking to produce the same results.</simpara></note>
</section>
</section>
<section id="history">
<title>History</title>
<simpara>This guide was started in 2013 by <ulink url="https://github.com/bbatsov">Bozhidar Batsov</ulink>, following the
success of a <ulink url="https://rubystyle.guide/">similar project</ulink> he had created in the Ruby community.</simpara>
<simpara>Bozhidar was very passionate about both Clojure and good programming style and he wanted to bridge the gap between what was
covered by the <ulink url="https://clojure.org/community/contrib_howto#_coding_guidelines">Clojure library coding guidelines</ulink> and what the style guides for languages like Java, Python and Ruby would typically cover.
Bozhidar still serves as the guide&#8217;s primary editor, but there&#8217;s an entire editor team supporting the project.</simpara>
<simpara>Since the inception of the guide we&#8217;ve received a lot of feedback from members of the exceptional Clojure community around the world.
Thanks for all the suggestions and the support! Together we can make a resource beneficial to each and every Clojure developer out there.</simpara>
</section>
<section id="sources_of_inspiration">
<title>Sources of Inspiration</title>
<simpara>Many people, books, presentations, articles and other style guides influenced the community Clojure style guide. Here are some of them:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://en.wikipedia.org/wiki/The_Elements_of_Style">"The Elements of Style"</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style">"The Elements of Programming Style"</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://www.python.org/dev/peps/pep-0008/">Python Style Guide (PEP-8)</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://rubystyle.guide/">Community Ruby Style Guide</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://google.github.io/styleguide/lispguide.xml">Google&#8217;s Common Lisp Style Guide</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://community.schemewiki.org/?scheme-style">scheme-style</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://clojure.org/community/contrib_howto#_coding_guidelines">Clojure Library Coding Guidelines</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://www.clojurebook.com/">"Clojure Programming"</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://joyofclojure.com/">"The Joy of Clojure"</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://elementsofclojure.com/">"Elements of Clojure"</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://pragprog.com/titles/vmclojeco/clojure-applied/">"Clojure Applied"</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://stuartsierra.com/tag/dos-and-donts">Stuart Sierra&#8217;s "Clojure Dos and Don&#8217;t" blog series</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="editor_team">
<title>Editor Team</title>
<simpara>The Clojure style guide is stewarded by an editor team of experienced
Clojurists that aims to reduce all the input we get (e.g. feedback and
suggestions) to a better reference for everyone.</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://metaredux.com/about/">Bozhidar Batsov</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://insideclojure.org/about/">Alex Miller</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://danielcompton.net/about">Daniel Compton</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://corfield.org/">Sean Corfield</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="contributing">
<title>Contributing</title>
<simpara>The guide is still a work in progress - some guidelines are lacking examples, some guidelines don&#8217;t have examples that illustrate them clearly enough.
Improving such guidelines is a great (and simple way) to help the Clojure community!</simpara>
<simpara>In due time these issues will (hopefully) be addressed - just keep them in mind for now.</simpara>
<simpara>Nothing written in this guide is set in stone.
It&#8217;s my desire to work together with everyone interested in Clojure coding style, so that we could ultimately create a resource that will be beneficial to the entire Clojure community.</simpara>
<simpara>Feel free to open tickets or send pull requests with improvements.
Thanks in advance for your help!</simpara>
<simpara>You can also support the style guide (and all my Clojure projects like
CIDER, nREPL, orchard, etc) with financial contributions via one of the following platforms:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://github.com/sponsors/bbatsov">GitHub Sponsors</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://ko-fi.com/bbatsov">ko-fi</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://www.patreon.com/bbatsov">Patreon</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="https://www.paypal.me/bbatsov">PayPal</ulink>
</simpara>
</listitem>
</itemizedlist>
<section id="how_to_contribute">
<title>How to Contribute?</title>
<simpara>It&#8217;s easy, just follow the contribution guidelines below:</simpara>
<itemizedlist>
<listitem>
<simpara>
<ulink url="https://help.github.com/articles/fork-a-repo">Fork</ulink> <ulink url="https://github.com/bbatsov/clojure-style-guide">bbatsov/clojure-style-guide</ulink> on GitHub
</simpara>
</listitem>
<listitem>
<simpara>
Make your feature addition or bug fix in a feature branch.
</simpara>
</listitem>
<listitem>
<simpara>
Include a <ulink url="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">good description</ulink> of your changes
</simpara>
</listitem>
<listitem>
<simpara>
Push your feature branch to GitHub
</simpara>
</listitem>
<listitem>
<simpara>
Send a <ulink url="https://help.github.com/articles/using-pull-requests">Pull Request</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="colophon">
<title>Colophon</title>
<simpara>This guide is written in <ulink url="https://asciidoc.org/">AsciiDoc</ulink> and is published as HTML using <ulink url="https://asciidoctor.org/">AsciiDoctor</ulink>.
The HTML version of the guide is hosted on GitHub Pages.</simpara>
<simpara>Originally the guide was written in Markdown, but was converted to AsciiDoc in 2019.</simpara>
</section>
<section id="license">
<title>License</title>
<simpara><inlinemediaobject>
  <imageobject>
  <imagedata fileref="https://i.creativecommons.org/l/by/3.0/88x31.png"/>
  </imageobject>
  <textobject><phrase>Creative Commons License</phrase></textobject>
</inlinemediaobject>
This work is licensed under a
<ulink url="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</ulink></simpara>
</section>
<section id="spread_the_word">
<title>Spread the Word</title>
<simpara>A community-driven style guide is of little use to a community that
doesn&#8217;t know about its existence. Tweet about the guide, share it with
your friends and colleagues. Every comment, suggestion or opinion we
get makes the guide just a little bit better. And we want to have the
best possible guide, don&#8217;t we?</simpara>
</section>
</article>
